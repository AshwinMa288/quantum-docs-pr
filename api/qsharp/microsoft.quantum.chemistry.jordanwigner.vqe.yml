### YamlMime:QSharpNamespace
# This file is automatically generated.
# Please do not modify this file manually, or your changes may be lost when
# documentation is rebuilt.
functions:
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAmpAmpByOracle has been deprecated. Please\
    \ use @\"microsoft.quantum.amplitudeamplification.standardamplitudeamplification\"\
    \ instead. Please use @\"microsoft.quantum.amplitudeamplification.standardamplitudeamplification\"\
    .", uid: Microsoft.Quantum.AmplitudeAmplification.AmpAmpByOracle}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAmpAmpByOraclePhases has been deprecated.\
    \ Please use @\"microsoft.quantum.amplitudeamplification.amplitudeamplificationfromstatepreparation\"\
    \ instead. Please use @\"microsoft.quantum.amplitudeamplification.amplitudeamplificationfromstatepreparation\"\
    .", uid: Microsoft.Quantum.AmplitudeAmplification.AmpAmpByOraclePhases}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAmpAmpByReflectionPhases has been deprecated.\
    \ Please use @\"microsoft.quantum.amplitudeamplification.amplitudeamplificationfrompartialreflections\"\
    \ instead. Please use @\"microsoft.quantum.amplitudeamplification.amplitudeamplificationfrompartialreflections\"\
    .", uid: Microsoft.Quantum.AmplitudeAmplification.AmpAmpByReflectionPhases}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAmpAmpObliviousByOraclePhases has been\
    \ deprecated. Please use @\"microsoft.quantum.amplitudeamplification.obliviousamplitudeamplificationfromstatepreparation\"\
    \ instead. Please use @\"microsoft.quantum.amplitudeamplification.obliviousamplitudeamplificationfromstatepreparation\"\
    .", uid: Microsoft.Quantum.AmplitudeAmplification.AmpAmpObliviousByOraclePhases}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAmpAmpObliviousByReflectionPhases has\
    \ been deprecated. Please use @\"microsoft.quantum.amplitudeamplification.obliviousamplitudeamplificationfrompartialreflections\"\
    \ instead. Please use @\"microsoft.quantum.amplitudeamplification.obliviousamplitudeamplificationfrompartialreflections\"\
    .", uid: Microsoft.Quantum.AmplitudeAmplification.AmpAmpObliviousByReflectionPhases}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAmpAmpPhasesFixedPoint has been deprecated.\
    \ Please use @\"microsoft.quantum.amplitudeamplification.fixedpointreflectionphases\"\
    \ instead. Please use @\"microsoft.quantum.amplitudeamplification.fixedpointreflectionphases\"\
    .", uid: Microsoft.Quantum.AmplitudeAmplification.AmpAmpPhasesFixedPoint}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAmpAmpPhasesStandard has been deprecated.\
    \ Please use @\"microsoft.quantum.amplitudeamplification.standardreflectionphases\"\
    \ instead. Please use @\"microsoft.quantum.amplitudeamplification.standardreflectionphases\"\
    .", uid: Microsoft.Quantum.AmplitudeAmplification.AmpAmpPhasesStandard}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAmpAmpRotationToReflectionPhases has\
    \ been deprecated. Please use @\"microsoft.quantum.amplitudeamplification.rotationphasesasreflectionphases\"\
    \ instead. Please use @\"microsoft.quantum.amplitudeamplification.rotationphasesasreflectionphases\"\
    .", uid: Microsoft.Quantum.AmplitudeAmplification.AmpAmpRotationToReflectionPhases}
- {summary: Amplitude amplification by partial reflections., uid: Microsoft.Quantum.AmplitudeAmplification.AmplitudeAmplificationFromPartialReflections}
- {summary: Amplitude amplification by oracles for partial reflections., uid: Microsoft.Quantum.AmplitudeAmplification.AmplitudeAmplificationFromStatePreparation}
- {summary: Computes partial reflection phases for fixed-point amplitude amplification.,
  uid: Microsoft.Quantum.AmplitudeAmplification.FixedPointReflectionPhases}
- {summary: Returns a unitary that implements oblivious amplitude amplification by
    specifying for partial reflections., uid: Microsoft.Quantum.AmplitudeAmplification.ObliviousAmplitudeAmplificationFromPartialReflections}
- {summary: Oblivious amplitude amplification by oracles for partial reflections.,
  uid: Microsoft.Quantum.AmplitudeAmplification.ObliviousAmplitudeAmplificationFromStatePreparation}
- {summary: "Constructs a reflection about the all-zero string |0...0\u232A, which\
    \ is the typical input state to amplitude amplification.", uid: Microsoft.Quantum.AmplitudeAmplification.ReflectionStart}
- {summary: Converts phases specified as single-qubit rotations to phases specified
    as partial reflections., uid: Microsoft.Quantum.AmplitudeAmplification.RotationPhasesAsReflectionPhases}
- {summary: Standard Amplitude Amplification algorithm, uid: Microsoft.Quantum.AmplitudeAmplification.StandardAmplitudeAmplification}
- {summary: Computes partial reflection phases for standard amplitude amplification.,
  uid: Microsoft.Quantum.AmplitudeAmplification.StandardReflectionPhases}
- {summary: "Constructs a `ReflectionOracle` about the target state uniquely marked\
    \ by the flag qubit.\nThe target state has a single qubit set to 1, and all others\
    \ 0: $\\ket{1}_f$.", uid: Microsoft.Quantum.AmplitudeAmplification.TargetStateReflectionOracle}
- {summary: Converts a `BigEndian` qubit register to a `LittleEndian` qubit register
    by reversing the qubit ordering., uid: Microsoft.Quantum.Arithmetic.BigEndianAsLittleEndian}
- {summary: 'If true, enables extra asserts that are expensive, but useful to debug
    the use of the arithmetic functions.', uid: Microsoft.Quantum.Arithmetic.ExtraArithmeticAssertionsEnabled}
- {summary: Assert that all fixed-point numbers in the provided array have identical
    point positions and qubit numbers., uid: Microsoft.Quantum.Arithmetic.IdenticalFormatFactFxP}
- {summary: 'Assert that all fixed-point numbers in the provided array have identical
    point positions when counting from the least- significant bit. I.e., number of
    bits minus point position must be constant for all fixed-point numbers in the
    array.', uid: Microsoft.Quantum.Arithmetic.IdenticalPointPosFactFxP}
- {summary: Converts a `LittleEndian` qubit register to a `BigEndian` qubit register
    by reversing the qubit ordering., uid: Microsoft.Quantum.Arithmetic.LittleEndianAsBigEndian}
- {summary: 'Given an operation that takes a big-endian input, returns a new operation
    that takes a little-endian input.', uid: Microsoft.Quantum.Arithmetic.ReversedOpBE}
- {summary: 'Given an operation that takes a big-endian input, returns a new operation
    that takes a little-endian input.', uid: Microsoft.Quantum.Arithmetic.ReversedOpBEA}
- {summary: 'Given an operation that takes a big-endian input, returns a new operation
    that takes a little-endian input.', uid: Microsoft.Quantum.Arithmetic.ReversedOpBEC}
- {summary: 'Given an operation that takes a big-endian input, returns a new operation
    that takes a little-endian input.', uid: Microsoft.Quantum.Arithmetic.ReversedOpBECA}
- {summary: 'Given an operation that takes a little-endian input, returns a new operation
    that takes a big-endian input.', uid: Microsoft.Quantum.Arithmetic.ReversedOpLE}
- {summary: 'Given an operation that takes a little-endian input, returns a new operation
    that takes a big-endian input.', uid: Microsoft.Quantum.Arithmetic.ReversedOpLEA}
- {summary: 'Given an operation that takes a little-endian input, returns a new operation
    that takes a big-endian input.', uid: Microsoft.Quantum.Arithmetic.ReversedOpLEC}
- {summary: 'Given an operation that takes a little-endian input, returns a new operation
    that takes a big-endian input.', uid: Microsoft.Quantum.Arithmetic.ReversedOpLECA}
- {summary: 'Given an array and a predicate that is defined for the elements of the
    array, and checks if all elements of the array satisfy the predicate.', uid: Microsoft.Quantum.Arrays.All}
- {summary: 'Given an array and a predicate that is defined for the elements of the
    array, checks if at least one element of the array satisfies the predicate.',
  uid: Microsoft.Quantum.Arrays.Any}
- {summary: Splits an array into multiple parts of equal length., uid: Microsoft.Quantum.Arrays.Chunks}
- {summary: Extracts a column from a matrix., uid: Microsoft.Quantum.Arrays.ColumnAt}
- {summary: This function does not check for matrix shape, uid: Microsoft.Quantum.Arrays.ColumnAtUnchecked}
- {summary: Creates an array of given length with all elements equal to given value.,
  uid: Microsoft.Quantum.Arrays.ConstantArray}
- {summary: 'Given an array and a predicate that is defined for the elements of the
    array, returns the number of elements an array that consists of those elements
    that satisfy the predicate.', uid: Microsoft.Quantum.Arrays.Count}
- {summary: Combines Mapped and Fold into a single function, uid: Microsoft.Quantum.Arrays.CumulativeFolded}
- {summary: Returns an array of diagonal elements of a 2-dimensional array, uid: Microsoft.Quantum.Arrays.Diagonal}
- {summary: Returns the at the given index of an array., uid: Microsoft.Quantum.Arrays.ElementAt}
- {summary: '', uid: Microsoft.Quantum.Arrays.ElementAtDiagonal}
- {summary: Returns the array's elements at a given range of indices., uid: Microsoft.Quantum.Arrays.ElementsAt}
- {summary: Returns the empty array of a given type., uid: Microsoft.Quantum.Arrays.EmptyArray}
- {summary: 'Given an array, returns a new array containing elements of the original
    array along with the indices of each element.', uid: Microsoft.Quantum.Arrays.Enumerated}
- {summary: 'Given two arrays of the same type and a predicate that is defined for
    pairs of elements of the arrays, checks whether the arrays are equal.', uid: Microsoft.Quantum.Arrays.EqualA}
- {summary: 'Returns an array containing the elements of another array, excluding
    elements at a given list of indices.', uid: Microsoft.Quantum.Arrays.Exclude}
- {summary: 'Returns an array containing the elements of another array, excluding
    elements at a given list of indices.', uid: Microsoft.Quantum.Arrays.Excluding}
- {summary: 'Given an array and a predicate that is defined for the elements of the
    array, returns an array that consists of those elements that satisfy the predicate.',
  uid: Microsoft.Quantum.Arrays.Filtered}
- {summary: 'Given an array and a function that maps an array element to some output
    array, returns the concatenated output arrays for each array element.', uid: Microsoft.Quantum.Arrays.FlatMapped}
- {summary: 'Given an array of arrays, returns the concatenation of all arrays.',
  uid: Microsoft.Quantum.Arrays.Flattened}
- {summary: 'Iterates a function `f` through an array `array`, returning `f(f(f(initialState,
    array[0]), array[1]), ...)`.', uid: Microsoft.Quantum.Arrays.Fold}
- {summary: Returns the first element of the array., uid: Microsoft.Quantum.Arrays.Head}
- {summary: Returns a tuple of first and all remaining elements of the array., uid: Microsoft.Quantum.Arrays.HeadAndRest}
- {summary: '', uid: Microsoft.Quantum.Arrays.Identity}
- {summary: 'Returns the first index of the first element in an array that satisfies
    a given predicate. If no such element exists, returns -1.', uid: Microsoft.Quantum.Arrays.IndexOf}
- {summary: 'Given an array, returns a range over the indices of that array, suitable
    for use in a for loop.', uid: Microsoft.Quantum.Arrays.IndexRange}
- {summary: Interleaves two arrays of (almost) same size., uid: Microsoft.Quantum.Arrays.Interleaved}
- {summary: Returns true if and only if an array is empty., uid: Microsoft.Quantum.Arrays.IsEmpty}
- {summary: Outputs true if and only if a given array represents a permutation., uid: Microsoft.Quantum.Arrays.IsPermutation}
- {summary: 'Given an array, returns whether that array is sorted as defined by a
    given comparison function.', uid: Microsoft.Quantum.Arrays.IsSorted}
- {summary: '', uid: Microsoft.Quantum.Arrays.IsValuePresent}
- {summary: 'Given an array, returns a function which returns elements of that array.',
  uid: Microsoft.Quantum.Arrays.LookupFunction}
- {summary: 'Given an array and a function that is defined for the elements of the
    array, returns a new array that consists of the images of the original array under
    the function.', uid: Microsoft.Quantum.Arrays.Mapped}
- {summary: 'Given an array and a function that is defined for the indexed elements
    of the array, returns a new array that consists of the images of the original
    array under the function.', uid: Microsoft.Quantum.Arrays.MappedByIndex}
- {summary: 'Given a range and a function that takes an integer as input, returns
    a new array that consists of the images of the range values under the function.',
  uid: Microsoft.Quantum.Arrays.MappedOverRange}
- {summary: 'Given two sorted arrays, returns a single array containing the elements
    of both in sorted order. Used internally by merge sort.', uid: Microsoft.Quantum.Arrays.Merged}
- {summary: Creates an array that is equal to an input array except that the last
    array element is dropped., uid: Microsoft.Quantum.Arrays.Most}
- {summary: Returns a tuple of all but one and the last element of the array., uid: Microsoft.Quantum.Arrays.MostAndTail}
- {summary: Returns an array padded at with specified values up to a specified length.,
  uid: Microsoft.Quantum.Arrays.Padded}
- {summary: Splits an array into multiple parts., uid: Microsoft.Quantum.Arrays.Partitioned}
- {summary: '', uid: Microsoft.Quantum.Arrays.Prefix}
- {summary: 'Given an array, returns all its prefixes.', uid: Microsoft.Quantum.Arrays.Prefixes}
- {summary: Represents a condition that a 2-dimensional array has a rectangular shape,
  uid: Microsoft.Quantum.Arrays.RectangularArrayFact}
- {summary: Creates an array that is equal to an input array except that the first
    array element is dropped., uid: Microsoft.Quantum.Arrays.Rest}
- {summary: Create an array that contains the same elements as an input array but
    in Reversed order., uid: Microsoft.Quantum.Arrays.Reversed}
- {summary: Get an array of integers in a given interval., uid: Microsoft.Quantum.Arrays.SequenceI}
- {summary: Get an array of integers in a given interval., uid: Microsoft.Quantum.Arrays.SequenceL}
- {summary: 'Given an array, returns the elements of that array sorted by a given
    comparison function.', uid: Microsoft.Quantum.Arrays.Sorted}
- {summary: Represents a condition that a 2-dimensional array has a square shape,
  uid: Microsoft.Quantum.Arrays.SquareArrayFact}
- {summary: Takes an array and a list of locations and produces a new array formed
    from the elements of the original array that match the given locations., uid: Microsoft.Quantum.Arrays.Subarray}
- {summary: Applies a swap of two elements in an array., uid: Microsoft.Quantum.Arrays.Swapped}
- {summary: Returns the last element of the array., uid: Microsoft.Quantum.Arrays.Tail}
- {summary: Returns the transpose of a matrix represented as an array of arrays.,
  uid: Microsoft.Quantum.Arrays.Transposed}
- {summary: Turns a list of 2-tuples into a nested array., uid: Microsoft.Quantum.Arrays.TupleArrayAsNestedArray}
- {summary: Returns a new array that has no equal adjacent elements., uid: Microsoft.Quantum.Arrays.Unique}
- {summary: 'Given an array of 2-tuples, returns a tuple of two arrays, each containing
    the elements of the tuples of the input array.', uid: Microsoft.Quantum.Arrays.Unzipped}
- {summary: 'Given a predicate and an array, returns the indices of that array where
    the predicate is true.', uid: Microsoft.Quantum.Arrays.Where}
- {summary: Returns all consecutive subarrays of length `size`., uid: Microsoft.Quantum.Arrays.Windows}
- {summary: "Given two arrays, returns a new array of pairs such that each pair contains\
    \ an element from each original array. > [!WARNING]\n> Deprecated\n\nZip has been\
    \ deprecated. Please use @\"microsoft.quantum.arrays.zipped\" instead.", uid: Microsoft.Quantum.Arrays.Zip}
- {summary: "Given three arrays, returns a new array of 3-tuples such that each 3-tuple\
    \ contains an element from each original array. > [!WARNING]\n> Deprecated\n\n\
    Zip3 has been deprecated. Please use @\"microsoft.quantum.arrays.zipped3\" instead.",
  uid: Microsoft.Quantum.Arrays.Zip3}
- {summary: "Given four arrays, returns a new array of 4-tuples such that each 4-tuple\
    \ contains an element from each original array. > [!WARNING]\n> Deprecated\n\n\
    Zip4 has been deprecated. Please use @\"microsoft.quantum.arrays.zipped4\" instead.",
  uid: Microsoft.Quantum.Arrays.Zip4}
- {summary: 'Given two arrays, returns a new array of pairs such that each pair contains
    an element from each original array.', uid: Microsoft.Quantum.Arrays.Zipped}
- {summary: 'Given three arrays, returns a new array of 3-tuples such that each 3-tuple
    contains an element from each original array.', uid: Microsoft.Quantum.Arrays.Zipped3}
- {summary: 'Given four arrays, returns a new array of 4-tuples such that each 4-tuple
    contains an element from each original array.', uid: Microsoft.Quantum.Arrays.Zipped4}
- {summary: Returns the order elements in an array need to be swapped to produce an
    ordered array. Assumes swaps occur in place., uid: Microsoft.Quantum.Arrays._SwapOrderToPermuteArray}
- {summary: Returns the bitwise AND of two integers. This performs the same computation
    as the built-in `&&&` operator., uid: Microsoft.Quantum.Bitwise.And}
- {summary: Shifts the bitwise representation of a number left by a given number of
    bits., uid: Microsoft.Quantum.Bitwise.LeftShiftedI}
- {summary: Shifts the bitwise representation of a number left by a given number of
    bits., uid: Microsoft.Quantum.Bitwise.LeftShiftedL}
- {summary: Returns the bitwise NOT of an integer. This performs the same computation
    as the built-in `~~~` operator., uid: Microsoft.Quantum.Bitwise.Not}
- {summary: Returns the bitwise OR of two integers. This performs the same computation
    as the built-in `|||` operator., uid: Microsoft.Quantum.Bitwise.Or}
- {summary: Returns the bitwise PARITY of an integer (1 if its binary representation
    contains odd number of ones and 0 otherwise)., uid: Microsoft.Quantum.Bitwise.Parity}
- {summary: Shifts the bitwise representation of a number right by a given number
    of bits., uid: Microsoft.Quantum.Bitwise.RightShiftedI}
- {summary: Shifts the bitwise representation of a number right by a given number
    of bits., uid: Microsoft.Quantum.Bitwise.RightShiftedL}
- {summary: Returns an integer representing the X bits of an array of Pauli operators.,
  uid: Microsoft.Quantum.Bitwise.XBits}
- {summary: Returns the bitwise exclusive-OR (XOR) of two integers. This performs
    the same computation as the built-in `^^^` operator., uid: Microsoft.Quantum.Bitwise.Xor}
- {summary: Returns an integer representing the Z bits of an array of Pauli operators.,
  uid: Microsoft.Quantum.Bitwise.ZBits}
- {summary: 'Returns 1, if `index` has an odd number of 1s and -1, if `index` has
    an even number of 1s.', uid: Microsoft.Quantum.Canon.Angle}
- {summary: '', uid: Microsoft.Quantum.Canon.AnyOutsideToleranceCP}
- {summary: '', uid: Microsoft.Quantum.Canon.AnyOutsideToleranceD}
- {summary: 'Arrange control, target, and helper qubits according to an index', uid: Microsoft.Quantum.Canon.ArrangedQubits}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nBigEndianToLittleEndian has been deprecated.\
    \ Please use @\"microsoft.quantum.arithmetic.bigendianaslittleendian\" instead.\
    \ Please use @\"Microsoft.Quantum.Arithmetic.BigEndianAsLittleEndian\".", uid: Microsoft.Quantum.Canon.BigEndianToLittleEndian}
- {summary: 'Given an array of operations acting on a single input, produces a new
    operation that performs each given operation in sequence.', uid: Microsoft.Quantum.Canon.Bound}
- {summary: 'Given an array of operations acting on a single input, produces a new
    operation that performs each given operation in sequence. The modifier `A` indicates
    that all operations in the array are adjointable.', uid: Microsoft.Quantum.Canon.BoundA}
- {summary: 'Given an array of operations acting on a single input, produces a new
    operation that performs each given operation in sequence. The modifier `C` indicates
    that all operations in the array are controllable.', uid: Microsoft.Quantum.Canon.BoundC}
- {summary: 'Given an array of operations acting on a single input, produces a new
    operation that performs each given operation in sequence. The modifier `CA` indicates
    that all operations in the array are adjointable and controllable.', uid: Microsoft.Quantum.Canon.BoundCA}
- {summary: 'Given an operation op, returns a new operation which applies the op if
    a classical control bit is true. If `false`, nothing happens.', uid: Microsoft.Quantum.Canon.CControlled}
- {summary: 'Given an operation op, returns a new operation which applies the op if
    a classical control bit is true. If `false`, nothing happens. The modifier `A`
    indicates that the operation is adjointable.', uid: Microsoft.Quantum.Canon.CControlledA}
- {summary: 'Given an operation op, returns a new operation which applies the op if
    a classical control bit is true. If `false`, nothing happens. The modifier `C`
    indicates that the operation is controllable.', uid: Microsoft.Quantum.Canon.CControlledC}
- {summary: 'Given an operation op, returns a new operation which applies the op if
    a classical control bit is true. If `false`, nothing happens. The modifier `CA`
    indicates that the operation is controllable and adjointable.', uid: Microsoft.Quantum.Canon.CControlledCA}
- {summary: Returns the composition of two functions., uid: Microsoft.Quantum.Canon.Compose}
- {summary: Returns the output of the composition of `inner` and `outer` for a given
    input., uid: Microsoft.Quantum.Canon.ComposedOutput}
- {summary: 'Given outer and inner operations, returns a new operation that conjugates
    the inner operation by the outer operation.', uid: Microsoft.Quantum.Canon.ConjugatedBy}
- {summary: 'Given outer and inner operations, returns a new operation that conjugates
    the inner operation by the outer operation.', uid: Microsoft.Quantum.Canon.ConjugatedByA}
- {summary: 'Given outer and inner operations, returns a new operation that conjugates
    the inner operation by the outer operation.', uid: Microsoft.Quantum.Canon.ConjugatedByC}
- {summary: 'Given outer and inner operations, returns a new operation that conjugates
    the inner operation by the outer operation.', uid: Microsoft.Quantum.Canon.ConjugatedByCA}
- {summary: Returns a unitary operation that applies an oracle on the target register
    if the control register state corresponds to a specified bit mask., uid: Microsoft.Quantum.Canon.ControlledOnBitString}
- {summary: Returns a unitary operator that applies an oracle on the target register
    if the control register state corresponds to a specified positive integer., uid: Microsoft.Quantum.Canon.ControlledOnInt}
- {summary: "Returns a curried version of an operation on two inputs.\nThat is, given\
    \ an operation with two inputs, this function applies Curry's isomorphism $f(x,\
    \ y) \\equiv f(x)(y)$ to return an operation of one input which returns an operation\
    \ of one input.", uid: Microsoft.Quantum.Canon.CurriedOp}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nDecomposeIntoTimeStepsCA has been deprecated.\
    \ Please use @\"microsoft.quantum.canon.decomposedintotimestepsca\" instead.",
  uid: Microsoft.Quantum.Canon.DecomposeIntoTimeStepsCA}
- {summary: "Returns an operation implementing the Trotter\u2013Suzuki integrator\
    \ for a given operation.", uid: Microsoft.Quantum.Canon.DecomposedIntoTimeStepsCA}
- {summary: Returns an operation that applies given operation with given argument.,
  uid: Microsoft.Quantum.Canon.Delayed}
- {summary: Returns an operation that applies given operation with given argument.,
  uid: Microsoft.Quantum.Canon.DelayedA}
- {summary: Returns an operation that applies given operation with given argument.,
  uid: Microsoft.Quantum.Canon.DelayedC}
- {summary: Returns an operation that applies given operation with given argument.,
  uid: Microsoft.Quantum.Canon.DelayedCA}
- {summary: 'Given a single-qubit Pauli operator and the index of a qubit, returns
    a multi-qubit Pauli operator with the given single-qubit operator at that index
    and `PauliI` at every other index.', uid: Microsoft.Quantum.Canon.EmbedPauli}
- {summary: 'Given a pair, returns its first element.', uid: Microsoft.Quantum.Canon.Fst}
- {summary: Creates Gray code sequences, uid: Microsoft.Quantum.Canon.GrayCode}
- {summary: 'Computes the Hamming weight of an integer, i.e., the number of 1s in
    its binary expansion.', uid: Microsoft.Quantum.Canon.HammingWeightI}
- {summary: Ignores the output of an operation or function., uid: Microsoft.Quantum.Canon.Ignore}
- {summary: Tests if a given Result value is equal to `One`., uid: Microsoft.Quantum.Canon.IsResultOne}
- {summary: Tests if a given Result value is equal to `Zero`., uid: Microsoft.Quantum.Canon.IsResultZero}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nLittleEndianToBigEndian has been deprecated.\
    \ Please use @\"microsoft.quantum.arithmetic.littleendianasbigendian\" instead.\
    \ Please use @\"Microsoft.Quantum.Arithmetic.LittleEndianAsBigEndian\".", uid: Microsoft.Quantum.Canon.LittleEndianToBigEndian}
- {summary: Implementation step of multiply-controlled Z rotations., uid: Microsoft.Quantum.Canon.MultiplexZCoefficients}
- {summary: "Returns a multiply-controlled unitary operation $U$ that applies a unitary\
    \ $V_j$ when controlled by n-qubit number state $\\ket{j}$.\n$U = \\sum^{2^n-1}_{j=0}\\\
    ket{j}\\bra{j}\\otimes V_j$.", uid: Microsoft.Quantum.Canon.MultiplexerBruteForceFromGenerator}
- {summary: "Returns a multiply-controlled unitary operation $U$ that applies a unitary\
    \ $V_j$ when controlled by n-qubit number state $\\ket{j}$.\n$U = \\sum^{2^n-1}_{j=0}\\\
    ket{j}\\bra{j}\\otimes V_j$.", uid: Microsoft.Quantum.Canon.MultiplexerFromGenerator}
- {summary: "Raises an operation to a power.\nThat is, given an operation representing\
    \ a gate $U$, returns a new operation $U^m$ for a power $m$.", uid: Microsoft.Quantum.Canon.OperationPow}
- {summary: "Raises an operation to a power. The modifier `A` indicates that the operation\
    \ is adjointable.\nThat is, given an operation representing a gate $U$, returns\
    \ a new operation $U^m$ for a power $m$.", uid: Microsoft.Quantum.Canon.OperationPowA}
- {summary: "Raises an operation to a power. The modifier `C` indicates that the operation\
    \ is controllable.\nThat is, given an operation representing a gate $U$, returns\
    \ a new operation $U^m$ for a power $m$.", uid: Microsoft.Quantum.Canon.OperationPowC}
- {summary: "Raises an operation to a power. The modifier `A` indicates that the operation\
    \ is controllable and adjointable.\nThat is, given an operation representing a\
    \ gate $U$, returns a new operation $U^m$ for a power $m$.", uid: Microsoft.Quantum.Canon.OperationPowCA}
- {summary: 'Restricts an operation to an array of indices of a register, i.e., a
    subregister.', uid: Microsoft.Quantum.Canon.RestrictedToSubregister}
- {summary: 'Restricts an operation to an array of indices of a register, i.e., a
    subregister. The modifier `A` indicates that the operation is adjointable.', uid: Microsoft.Quantum.Canon.RestrictedToSubregisterA}
- {summary: 'Restricts an operation to an array of indices of a register, i.e., a
    subregister. The modifier `C` indicates that the operation is controllable.',
  uid: Microsoft.Quantum.Canon.RestrictedToSubregisterC}
- {summary: 'Restricts an operation to an array of indices of a register, i.e., a
    subregister. The modifier `CA` indicates that the operation is controllable and
    adjointable.', uid: Microsoft.Quantum.Canon.RestrictedToSubregisterCA}
- {summary: 'Given a pair, returns its second element.', uid: Microsoft.Quantum.Canon.Snd}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nStackCapacity has been deprecated.",
  uid: Microsoft.Quantum.Canon.StackCapacity}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nStackLength has been deprecated.", uid: Microsoft.Quantum.Canon.StackLength}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nStackNew has been deprecated.", uid: Microsoft.Quantum.Canon.StackNew}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nStackPeek has been deprecated.", uid: Microsoft.Quantum.Canon.StackPeek}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nStackPop has been deprecated.", uid: Microsoft.Quantum.Canon.StackPop}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nStackPush has been deprecated.", uid: Microsoft.Quantum.Canon.StackPush}
- {summary: 'Given a function and an operation, returns a new operation whose input
    is transformed by the given function.', uid: Microsoft.Quantum.Canon.TransformedOperation}
- {summary: 'Given a function and an operation, returns a new operation whose input
    is transformed by the given function.', uid: Microsoft.Quantum.Canon.TransformedOperationA}
- {summary: 'Given a function and an operation, returns a new operation whose input
    is transformed by the given function.', uid: Microsoft.Quantum.Canon.TransformedOperationC}
- {summary: 'Given a function and an operation, returns a new operation whose input
    is transformed by the given function.', uid: Microsoft.Quantum.Canon.TransformedOperationCA}
- {summary: Computes Trotter step size in recursive implementation of Trotter simulation
    algorithm., uid: Microsoft.Quantum.Canon.TrotterStepSize}
- {summary: 'Given a function which returns operations, returns a new operation which
    takes both inputs as a tuple.', uid: Microsoft.Quantum.Canon.UncurriedOp}
- {summary: 'Given a function which returns operations, returns a new operation which
    takes both inputs as a tuple. The modifier `A` indicates that the operations are
    adjointable.', uid: Microsoft.Quantum.Canon.UncurriedOpA}
- {summary: 'Given a function which returns operations, returns a new operation which
    takes both inputs as a tuple. The modifier `C` indicates that the operations are
    controllable.', uid: Microsoft.Quantum.Canon.UncurriedOpC}
- {summary: 'Given a function which returns operations, returns a new operation which
    takes both inputs as a tuple. The modifier `CA` indicates that the operations
    are controllable and adjointable.', uid: Microsoft.Quantum.Canon.UncurriedOpCA}
- {summary: Returns an array of all weight-1 Pauli operators on a given number of
    qubits., uid: Microsoft.Quantum.Canon.WeightOnePaulis}
- {summary: '', uid: Microsoft.Quantum.Canon.WithFirstInputApplied}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nXOR has been deprecated. Please use @\"\
    microsoft.quantum.logical.xor\" instead. Please use @\"microsoft.quantum.logical.xor\"\
    .", uid: Microsoft.Quantum.Canon.XOR}
- {summary: '', uid: Microsoft.Quantum.Characterization.HeadMeasurement}
- {summary: Converts a Hamiltonian term in `HTerm` data format to a GeneratorIndex.,
  uid: Microsoft.Quantum.Chemistry.HTermToGenIdx}
- {summary: 'Converts an index to a Hamiltonian term in `HTerm[]` data format to a
    GeneratorIndex.', uid: Microsoft.Quantum.Chemistry.HTermsToGenIdx}
- {summary: 'Converts a Hamiltonian in `HTerm[]` data format to a GeneratorSystem.',
  uid: Microsoft.Quantum.Chemistry.HTermsToGenSys}
- {summary: Checks whether a `Double` number is not approximately zero., uid: Microsoft.Quantum.Chemistry.IsNotZero}
- {summary: Converts a Hamiltonian described by `JWOptimizedHTerms` to a `GeneratorSystem`
    expressed in terms of the Pauli `GeneratorIndex`., uid: Microsoft.Quantum.Chemistry.JordanWigner.JordanWignerBlockEncodingGeneratorSystem}
- {summary: Represents a dynamical generator as a set of simulatable gates and an
    expansion in the JordanWigner basis., uid: Microsoft.Quantum.Chemistry.JordanWigner.JordanWignerClusterOperatorEvolutionSet}
- {summary: Converts a Hamiltonian described by `JWOptimizedHTerms` to a `GeneratorSystem`
    expressed in terms of the `GeneratorIndex` convention defined in this file., uid: Microsoft.Quantum.Chemistry.JordanWigner.JordanWignerClusterOperatorGeneratorSystem}
- {summary: Represents a dynamical generator as a set of simulatable gates and an
    expansion in the JordanWigner basis., uid: Microsoft.Quantum.Chemistry.JordanWigner.JordanWignerFermionEvolutionSet}
- {summary: Represents a dynamical generator as a set of simulatable gates and an
    expansion in the JordanWigner basis., uid: Microsoft.Quantum.Chemistry.JordanWigner.JordanWignerFermionFunction}
- {summary: Converts a Hamiltonian described by `JWOptimizedHTerms` to a `GeneratorSystem`
    expressed in terms of the `GeneratorIndex` convention defined in this file., uid: Microsoft.Quantum.Chemistry.JordanWigner.JordanWignerGeneratorSystem}
- {summary: Converts a Hamiltonian described by `JWOptimizedHTerms` to a `GeneratorSystem`
    expressed in terms of the Pauli `GeneratorIndex`., uid: Microsoft.Quantum.Chemistry.JordanWigner.OptimizedBlockEncodingGeneratorSystem}
- {summary: Returns T-count optimized Qubitization operation and the parameters necessary
    to run it., uid: Microsoft.Quantum.Chemistry.JordanWigner.OptimizedQubitizationOracle}
- {summary: Returns Qubitization operation and the parameters necessary to run it.,
  uid: Microsoft.Quantum.Chemistry.JordanWigner.QubitizationOracle}
- {summary: Returns Trotter step operation and the parameters necessary to run it.,
  uid: Microsoft.Quantum.Chemistry.JordanWigner.TrotterStepOracle}
- {summary: Expands the compact representation of the Jordan-Wigner coefficients in
    order to obtain a one-to-one mapping between these and Pauli terms., uid: Microsoft.Quantum.Chemistry.JordanWigner.VQE.ExpandedCoefficients}
- {summary: Computes all the measurement operators required to compute the expectation
    of a Jordan-Wigner term., uid: Microsoft.Quantum.Chemistry.JordanWigner.VQE.MeasurementOperators}
- {summary: "Computes Z component of Jordan\u2013Wigner string between fermion indices\
    \ in a fermionic operator with an even number of creation / annihilation operators.",
  uid: Microsoft.Quantum.Chemistry.JordanWigner._ComputeJordanWignerBitString}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._ComputeJordanWignerPauliString}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._ComputeJordanWignerPauliZString}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._GetOptimizedBETermIndexCoeff_}
- {summary: Represents a dynamical generator as a set of simulatable gates and an
    expansion in the JordanWigner basis., uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerClusterOperatorFunction}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerClusterOperatorGeneratorIndex}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerClusterOperatorGeneratorSystemImpl}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerClusterOperatorPQRSTermSigns}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerOptimizedBlockEncodingQubitCount_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerOptimizedBlockEncodingQubitManager_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerOptimizedBlockEncoding_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerOptimizedQuantumWalkByQubitization_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerSelectQubitCount_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerSelectQubitManager_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._OptimizedBEGeneratorSystemCoeff_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._OptimizedBEXY_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._OptimizedQubitizationOracleSeperatedRegisters_}
- {summary: "Converts a GeneratorIndex describing a PQ term to an expression 'GeneratorIndex[]'\
    \ in terms of Paulis", uid: Microsoft.Quantum.Chemistry.JordanWigner._PQTermToPauliGenIdx_}
- {summary: "Converts a GeneratorIndex describing a PQ term to an expression 'GeneratorIndex[]'\
    \ in terms of Paulis", uid: Microsoft.Quantum.Chemistry.JordanWigner._PQTermToPauliMajIdx_}
- {summary: "Converts a GeneratorIndex describing a PQ or PQQR term to an expression\
    \ 'GeneratorIndex[]' in terms of Paulis", uid: Microsoft.Quantum.Chemistry.JordanWigner._PQandPQQRTermToPauliGenIdx_}
- {summary: "Converts a GeneratorIndex describing a PQ or PQQR term to an expression\
    \ 'GeneratorIndex[]' in terms of Paulis", uid: Microsoft.Quantum.Chemistry.JordanWigner._PQandPQQRTermToPauliMajIdx_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._PrepareSingleConfigurationalStateSingleSiteOccupation}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._QubitizationOracleSeperatedRegisters}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._SelectZ_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._ToJordanWignerSelectInput_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._ToPauliBases_}
- {summary: "Converts a GeneratorIndex describing a PQRS term to an expression 'GeneratorIndex[]'\
    \ in terms of Paulis", uid: Microsoft.Quantum.Chemistry.JordanWigner._V0123TermToPauliGenIdx_}
- {summary: "Converts a GeneratorIndex describing a PQRS term to an expression 'GeneratorIndex[]'\
    \ in terms of Paulis", uid: Microsoft.Quantum.Chemistry.JordanWigner._V0123TermToPauliMajIdx_}
- {summary: "Converts a GeneratorIndex describing a Z term to an expression 'GeneratorIndex[]'\
    \ in terms of Paulis.", uid: Microsoft.Quantum.Chemistry.JordanWigner._ZTermToPauliGenIdx}
- {summary: "Converts a GeneratorIndex describing a Z term to an expression 'GeneratorIndex[]'\
    \ in terms of Paulis.", uid: Microsoft.Quantum.Chemistry.JordanWigner._ZTermToPauliMajIdx_}
- {summary: "Converts a GeneratorIndex describing a ZZ term to an expression 'GeneratorIndex[]'\
    \ in terms of Paulis.", uid: Microsoft.Quantum.Chemistry.JordanWigner._ZZTermToPauliGenIdx}
- {summary: "Converts a GeneratorIndex describing a ZZ term to an expression 'GeneratorIndex[]'\
    \ in terms of Paulis.", uid: Microsoft.Quantum.Chemistry.JordanWigner._ZZTermToPauliMajIdx_}
- {summary: Converts a given big integer to an array of Booleans. The 0 element of
    the array is the least significant bit of the big integer., uid: Microsoft.Quantum.Convert.BigIntAsBoolArray}
- {summary: Converts a given array of Booleans to an equivalent big integer. The 0
    element of the array is the least significant bit of the big integer., uid: Microsoft.Quantum.Convert.BoolArrayAsBigInt}
- {summary: Produces a positive integer from a string of bits in little endian format.,
  uid: Microsoft.Quantum.Convert.BoolArrayAsInt}
- {summary: 'Given a bit string, returns a multi-qubit Pauli operator represented
    as an array of single-qubit Pauli operators.', uid: Microsoft.Quantum.Convert.BoolArrayAsPauli}
- {summary: 'Converts a `Bool[]` type to a `Result[]` type, where `true` is mapped
    to `One` and `false` is mapped to `Zero`.', uid: Microsoft.Quantum.Convert.BoolArrayAsResultArray}
- {summary: 'Converts a `Bool` type to a `Result` type, where `true` is mapped to
    `One` and `false` is mapped to `Zero`.', uid: Microsoft.Quantum.Convert.BoolAsResult}
- {summary: Converts a given boolean value to an equivalent string representation.,
  uid: Microsoft.Quantum.Convert.BoolAsString}
- {summary: Converts a given double-precision floating-point number to an equivalent
    string representation., uid: Microsoft.Quantum.Convert.DoubleAsString}
- {summary: 'Converts a given double-precision floating-point number to an equivalent
    string representation, using the given format.', uid: Microsoft.Quantum.Convert.DoubleAsStringWithFormat}
- {summary: Converts functions to operations., uid: Microsoft.Quantum.Convert.FunctionAsOperation}
- {summary: Converts a given integer to an equivalent big integer., uid: Microsoft.Quantum.Convert.IntAsBigInt}
- {summary: 'Produces a binary representation of a positive integer, using the little-endian
    representation for the returned array.', uid: Microsoft.Quantum.Convert.IntAsBoolArray}
- {summary: Converts a given integer to an equivalent double-precision floating-point
    number., uid: Microsoft.Quantum.Convert.IntAsDouble}
- {summary: Converts a given integer number to an equivalent string representation.,
  uid: Microsoft.Quantum.Convert.IntAsString}
- {summary: 'Converts a given integer number to an equivalent string representation,
    using the given format.', uid: Microsoft.Quantum.Convert.IntAsStringWithFormat}
- {summary: 'Converts a given big integer to an equivalent integer, if possible. The
    function returns a pair of the resulting integer and a Boolean flag which is true,
    if and only if the conversion was possible.', uid: Microsoft.Quantum.Convert.MaybeBigIntAsInt}
- {summary: Encodes a multi-qubit Pauli operator represented as an array of single-qubit
    Pauli operators into an integer., uid: Microsoft.Quantum.Convert.PauliArrayAsInt}
- {summary: Creates an array `arr` of integers enumerated by start..step..end., uid: Microsoft.Quantum.Convert.RangeAsIntArray}
- {summary: 'Converts a `Result[]` type to a `Bool[]` type, where `One` is mapped
    to `true` and `Zero` is mapped to `false`.', uid: Microsoft.Quantum.Convert.ResultArrayAsBoolArray}
- {summary: Produces a positive integer from a string of Results in little endian
    format., uid: Microsoft.Quantum.Convert.ResultArrayAsInt}
- {summary: 'Converts a `Result` type to a `Bool` type, where `One` is mapped to `true`
    and `Zero` is mapped to `false`.', uid: Microsoft.Quantum.Convert.ResultAsBool}
- {summary: Returns a default instance of the specified type., uid: Microsoft.Quantum.Core.Default}
- {summary: Returns the number of elements in an array., uid: Microsoft.Quantum.Core.Length}
- {summary: 'Returns the defined end value of the given range, which is not necessarily
    the last element in the sequence.', uid: Microsoft.Quantum.Core.RangeEnd}
- {summary: Returns a new range which is the reverse of the input range., uid: Microsoft.Quantum.Core.RangeReverse}
- {summary: Returns the defined start value of the given range., uid: Microsoft.Quantum.Core.RangeStart}
- {summary: Returns the integer that specifies how the next value of a range is calculated.,
  uid: Microsoft.Quantum.Core.RangeStep}
- {summary: Asserts that two arrays of boolean values are equal., uid: Microsoft.Quantum.Diagnostics.AllEqualityFactB}
- {summary: Asserts that two arrays of integer values are equal., uid: Microsoft.Quantum.Diagnostics.AllEqualityFactI}
- {summary: Declares that a classical condition is false., uid: Microsoft.Quantum.Diagnostics.Contradiction}
- {summary: Dumps the current target machine's status., uid: Microsoft.Quantum.Diagnostics.DumpMachine}
- {summary: Dumps the current target machine's status associated with the given qubits.,
  uid: Microsoft.Quantum.Diagnostics.DumpRegister}
- {summary: Asserts that a classical Bool variable has the expected value., uid: Microsoft.Quantum.Diagnostics.EqualityFactB}
- {summary: Asserts that a complex number has the expected value., uid: Microsoft.Quantum.Diagnostics.EqualityFactC}
- {summary: Asserts that a complex number has the expected value., uid: Microsoft.Quantum.Diagnostics.EqualityFactCP}
- {summary: Asserts that a classical Int variable has the expected value., uid: Microsoft.Quantum.Diagnostics.EqualityFactI}
- {summary: Asserts that a classical BigInt variable has the expected value., uid: Microsoft.Quantum.Diagnostics.EqualityFactL}
- {summary: Asserts that a classical Result variable has the expected value., uid: Microsoft.Quantum.Diagnostics.EqualityFactR}
- {summary: Represents the claim that a classical floating point value has the expected
    value up to a given absolute tolerance., uid: Microsoft.Quantum.Diagnostics.EqualityWithinToleranceFact}
- {summary: Declares that a classical condition is true., uid: Microsoft.Quantum.Diagnostics.Fact}
- {summary: Internal function used to fail with meaningful error messages., uid: Microsoft.Quantum.Diagnostics.FormattedFailure}
- {summary: Asserts that a classical complex number has the expected value up to a
    small tolerance of 1e-10., uid: Microsoft.Quantum.Diagnostics.NearEqualityFactC}
- {summary: Asserts that a classical complex number has the expected value up to a
    small tolerance of 1e-10., uid: Microsoft.Quantum.Diagnostics.NearEqualityFactCP}
- {summary: Asserts that a classical floating point value has the expected value up
    to a small tolerance of 1e-10., uid: Microsoft.Quantum.Diagnostics.NearEqualityFactD}
- {summary: "Returns a QECC value representing the \u27E63, 1, 1\u27E7 bit flip code\
    \ encoder and decoder with in-place syndrome measurement.", uid: Microsoft.Quantum.ErrorCorrection.BitFlipCode}
- {summary: "Function for recovery Pauli operations for given syndrome measurement\
    \ by table lookup for the \u27E63, 1, 1\u27E7 bit flip code.", uid: Microsoft.Quantum.ErrorCorrection.BitFlipRecoveryFn}
- {summary: "Returns a QECC value representing the \u27E65, 1, 3\u27E7 code encoder\
    \ and decoder with in-place syndrome measurement.", uid: Microsoft.Quantum.ErrorCorrection.FiveQubitCode}
- {summary: "Returns function that maps error syndrome measurements to the appropriate\
    \ error-correcting Pauli operators by table lookup for the \u27E65, 1, 3\u27E7\
    \ quantum code.", uid: Microsoft.Quantum.ErrorCorrection.FiveQubitCodeRecoveryFn}
- {summary: "Returns a CSS value representing the \u27E67, 1, 3\u27E7 Steane code\
    \ encoder and decoder with in-place syndrome measurement.", uid: Microsoft.Quantum.ErrorCorrection.SteaneCode}
- {summary: "Decoder for combined X- and Z-parts of the stabilizer group of the \u27E6\
    7, 1, 3\u27E7 Steane quantum code.", uid: Microsoft.Quantum.ErrorCorrection.SteaneCodeRecoveryFns}
- {summary: "Decoder for the X-part of the stabilizer group of the \u27E67, 1, 3\u27E7\
    \ Steane quantum code.", uid: Microsoft.Quantum.ErrorCorrection.SteaneCodeRecoveryX}
- {summary: "Decoder for the Z-part of the stabilizer group of the \u27E67, 1, 3\u27E7\
    \ Steane quantum code.", uid: Microsoft.Quantum.ErrorCorrection.SteaneCodeRecoveryZ}
- {summary: 'For a given table of Pauli operations on a given register of qubits,
    this function returns an object of type `RecoveryFn` which contains all information
    needed to perform a table-lookup decoding with respect to the given array of Pauli
    operations.', uid: Microsoft.Quantum.ErrorCorrection.TableLookupRecovery}
- {summary: '', uid: Microsoft.Quantum.ErrorCorrection.TableLookupRecoveryImpl}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAnd has been deprecated. Please use @\"\
    microsoft.quantum.bitwise.and\" instead. Please use @\"microsoft.quantum.bitwise.and\"\
    .", uid: Microsoft.Quantum.Extensions.Bitwise.And}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nNot has been deprecated. Please use @\"\
    microsoft.quantum.bitwise.not\" instead. Please use @\"microsoft.quantum.bitwise.not\"\
    .", uid: Microsoft.Quantum.Extensions.Bitwise.Not}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nOr has been deprecated. Please use @\"\
    microsoft.quantum.bitwise.or\" instead. Please use @\"microsoft.quantum.bitwise.or\"\
    .", uid: Microsoft.Quantum.Extensions.Bitwise.Or}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nParity has been deprecated. Please use\
    \ @\"microsoft.quantum.bitwise.parity\" instead. Please use @\"microsoft.quantum.bitwise.parity\"\
    .", uid: Microsoft.Quantum.Extensions.Bitwise.Parity}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nXBits has been deprecated. Please use\
    \ @\"microsoft.quantum.bitwise.xbits\" instead. Please use @\"microsoft.quantum.bitwise.xbits\"\
    .", uid: Microsoft.Quantum.Extensions.Bitwise.XBits}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nXor has been deprecated. Please use @\"\
    microsoft.quantum.bitwise.xor\" instead. Please use @\"microsoft.quantum.bitwise.xor\"\
    .", uid: Microsoft.Quantum.Extensions.Bitwise.Xor}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nZBits has been deprecated. Please use\
    \ @\"microsoft.quantum.bitwise.zbits\" instead. Please use @\"microsoft.quantum.bitwise.zbits\"\
    .", uid: Microsoft.Quantum.Extensions.Bitwise.ZBits}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nBigIntToBools has been deprecated. Please\
    \ use @\"microsoft.quantum.convert.bigintasboolarray\" instead. Please use @\"\
    microsoft.quantum.convert.bigintasboolarray\".", uid: Microsoft.Quantum.Extensions.Convert.BigIntToBools}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nBoolsToBigInt has been deprecated. Please\
    \ use @\"microsoft.quantum.convert.boolarrayasbigint\" instead. Please use @\"\
    microsoft.quantum.convert.boolarrayasbigint\".", uid: Microsoft.Quantum.Extensions.Convert.BoolsToBigInt}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nPauliArrayToInt has been deprecated.\
    \ Please use @\"microsoft.quantum.convert.pauliarrayasint\" instead. Please use\
    \ @\"microsoft.quantum.convert.pauliarrayasint\".", uid: Microsoft.Quantum.Extensions.Convert.PauliArrayToInt}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nToBigInt has been deprecated. Please\
    \ use @\"microsoft.quantum.convert.intasbigint\" instead. Please use @\"microsoft.quantum.convert.intasbigint\"\
    .", uid: Microsoft.Quantum.Extensions.Convert.ToBigInt}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nToDouble has been deprecated. Please\
    \ use @\"microsoft.quantum.convert.intasdouble\" instead. Please use @\"microsoft.quantum.convert.intasdouble\"\
    .", uid: Microsoft.Quantum.Extensions.Convert.ToDouble}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nToStringB has been deprecated. Please\
    \ use @\"microsoft.quantum.convert.boolasstring\" instead. Please use @\"microsoft.quantum.convert.boolasstring\"\
    .", uid: Microsoft.Quantum.Extensions.Convert.ToStringB}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nToStringD has been deprecated. Please\
    \ use @\"microsoft.quantum.convert.doubleasstring\" instead. Please use @\"microsoft.quantum.convert.doubleasstring\"\
    .", uid: Microsoft.Quantum.Extensions.Convert.ToStringD}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nToStringDFormat has been deprecated.\
    \ Please use @\"microsoft.quantum.convert.doubleasstringwithformat\" instead.\
    \ Please use @\"microsoft.quantum.convert.doubleasstringwithformat\".", uid: Microsoft.Quantum.Extensions.Convert.ToStringDFormat}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nToStringI has been deprecated. Please\
    \ use @\"microsoft.quantum.convert.intasstring\" instead. Please use @\"microsoft.quantum.convert.intasstring\"\
    .", uid: Microsoft.Quantum.Extensions.Convert.ToStringI}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nToStringIFormat has been deprecated.\
    \ Please use @\"microsoft.quantum.convert.intasstringwithformat\" instead. Please\
    \ use @\"microsoft.quantum.convert.intasstringwithformat\".", uid: Microsoft.Quantum.Extensions.Convert.ToStringIFormat}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nDumpMachine has been deprecated. Please\
    \ use @\"microsoft.quantum.diagnostics.dumpmachine\" instead. Please use @\"microsoft.quantum.diagnostics.dumpmachine\"\
    .", uid: Microsoft.Quantum.Extensions.Diagnostics.DumpMachine}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nDumpRegister has been deprecated. Please\
    \ use @\"microsoft.quantum.diagnostics.dumpregister\" instead. Please use @\"\
    microsoft.quantum.diagnostics.dumpregister\".", uid: Microsoft.Quantum.Extensions.Diagnostics.DumpRegister}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAbsB has been deprecated. Please use\
    \ @\"microsoft.quantum.math.absl\" instead. Please use @\"microsoft.quantum.math.absl\"\
    .", uid: Microsoft.Quantum.Extensions.Math.AbsB}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAbsD has been deprecated. Please use\
    \ @\"microsoft.quantum.math.absd\" instead. Please use @\"microsoft.quantum.math.absd\"\
    .", uid: Microsoft.Quantum.Extensions.Math.AbsD}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAbsI has been deprecated. Please use\
    \ @\"microsoft.quantum.math.absi\" instead. Please use @\"microsoft.quantum.math.absi\"\
    .", uid: Microsoft.Quantum.Extensions.Math.AbsI}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nArcCos has been deprecated. Please use\
    \ @\"microsoft.quantum.math.arccos\" instead. Please use @\"microsoft.quantum.math.arccos\"\
    .", uid: Microsoft.Quantum.Extensions.Math.ArcCos}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nArcSin has been deprecated. Please use\
    \ @\"microsoft.quantum.math.arcsin\" instead. Please use @\"microsoft.quantum.math.arcsin\"\
    .", uid: Microsoft.Quantum.Extensions.Math.ArcSin}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nArcTan has been deprecated. Please use\
    \ @\"microsoft.quantum.math.arctan\" instead. Please use @\"microsoft.quantum.math.arctan\"\
    .", uid: Microsoft.Quantum.Extensions.Math.ArcTan}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nArcTan2 has been deprecated. Please use\
    \ @\"microsoft.quantum.math.arctan2\" instead. Please use @\"microsoft.quantum.math.arctan2\"\
    .", uid: Microsoft.Quantum.Extensions.Math.ArcTan2}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nCeiling has been deprecated. Please use\
    \ @\"microsoft.quantum.math.ceiling\" instead. Please use @\"microsoft.quantum.math.ceiling\"\
    .", uid: Microsoft.Quantum.Extensions.Math.Ceiling}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nCos has been deprecated. Please use @\"\
    microsoft.quantum.math.cos\" instead. Please use @\"microsoft.quantum.math.cos\"\
    .", uid: Microsoft.Quantum.Extensions.Math.Cos}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nCosh has been deprecated. Please use\
    \ @\"microsoft.quantum.math.cosh\" instead. Please use @\"microsoft.quantum.math.cosh\"\
    .", uid: Microsoft.Quantum.Extensions.Math.Cosh}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nDivRemB has been deprecated. Please use\
    \ @\"microsoft.quantum.math.divreml\" instead. Please use @\"microsoft.quantum.math.divreml\"\
    .", uid: Microsoft.Quantum.Extensions.Math.DivRemB}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nE has been deprecated. Please use @\"\
    microsoft.quantum.math.e\" instead. Please use @\"microsoft.quantum.math.e\".",
  uid: Microsoft.Quantum.Extensions.Math.E}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nExpD has been deprecated. Please use\
    \ @\"microsoft.quantum.math.expd\" instead. Please use @\"microsoft.quantum.math.expd\"\
    .", uid: Microsoft.Quantum.Extensions.Math.ExpD}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nFloor has been deprecated. Please use\
    \ @\"microsoft.quantum.math.floor\" instead. Please use @\"microsoft.quantum.math.floor\"\
    .", uid: Microsoft.Quantum.Extensions.Math.Floor}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nIEEERemainder has been deprecated. Please\
    \ use @\"microsoft.quantum.math.ieeeremainder\" instead. Please use @\"microsoft.quantum.math.ieeeremainder\"\
    .", uid: Microsoft.Quantum.Extensions.Math.IEEERemainder}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nLog has been deprecated. Please use @\"\
    microsoft.quantum.math.log\" instead. Please use @\"microsoft.quantum.math.log\"\
    .", uid: Microsoft.Quantum.Extensions.Math.Log}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nLog10 has been deprecated. Please use\
    \ @\"microsoft.quantum.math.log10\" instead. Please use @\"microsoft.quantum.math.log10\"\
    .", uid: Microsoft.Quantum.Extensions.Math.Log10}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nMaxB has been deprecated. Please use\
    \ @\"microsoft.quantum.math.maxl\" instead. Please use @\"microsoft.quantum.math.maxl\"\
    .", uid: Microsoft.Quantum.Extensions.Math.MaxB}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nMaxD has been deprecated. Please use\
    \ @\"microsoft.quantum.math.maxd\" instead. Please use @\"microsoft.quantum.math.maxd\"\
    .", uid: Microsoft.Quantum.Extensions.Math.MaxD}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nMaxI has been deprecated. Please use\
    \ @\"microsoft.quantum.math.maxi\" instead. Please use @\"microsoft.quantum.math.maxi\"\
    .", uid: Microsoft.Quantum.Extensions.Math.MaxI}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nMinB has been deprecated. Please use\
    \ @\"microsoft.quantum.math.minl\" instead. Please use @\"microsoft.quantum.math.minl\"\
    .", uid: Microsoft.Quantum.Extensions.Math.MinB}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nMinD has been deprecated. Please use\
    \ @\"microsoft.quantum.math.mind\" instead. Please use @\"microsoft.quantum.math.mind\"\
    .", uid: Microsoft.Quantum.Extensions.Math.MinD}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nMinI has been deprecated. Please use\
    \ @\"microsoft.quantum.math.mini\" instead. Please use @\"microsoft.quantum.math.mini\"\
    .", uid: Microsoft.Quantum.Extensions.Math.MinI}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nModPowB has been deprecated. Please use\
    \ @\"microsoft.quantum.math.modpowl\" instead. Please use @\"microsoft.quantum.math.modpowl\"\
    .", uid: Microsoft.Quantum.Extensions.Math.ModPowB}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nPI has been deprecated. Please use @\"\
    microsoft.quantum.math.pi\" instead. Please use @\"microsoft.quantum.math.pi\"\
    .", uid: Microsoft.Quantum.Extensions.Math.PI}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nPowD has been deprecated. Please use\
    \ @\"microsoft.quantum.math.powd\" instead. Please use @\"microsoft.quantum.math.powd\"\
    .", uid: Microsoft.Quantum.Extensions.Math.PowD}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nRound has been deprecated. Please use\
    \ @\"microsoft.quantum.math.round\" instead. Please use @\"microsoft.quantum.math.round\"\
    .", uid: Microsoft.Quantum.Extensions.Math.Round}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nSignB has been deprecated. Please use\
    \ @\"microsoft.quantum.math.signl\" instead. Please use @\"microsoft.quantum.math.signl\"\
    .", uid: Microsoft.Quantum.Extensions.Math.SignB}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nSignD has been deprecated. Please use\
    \ @\"microsoft.quantum.math.signd\" instead. Please use @\"microsoft.quantum.math.signd\"\
    .", uid: Microsoft.Quantum.Extensions.Math.SignD}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nSignI has been deprecated. Please use\
    \ @\"microsoft.quantum.math.signi\" instead. Please use @\"microsoft.quantum.math.signi\"\
    .", uid: Microsoft.Quantum.Extensions.Math.SignI}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nSin has been deprecated. Please use @\"\
    microsoft.quantum.math.sin\" instead. Please use @\"microsoft.quantum.math.sin\"\
    .", uid: Microsoft.Quantum.Extensions.Math.Sin}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nSinh has been deprecated. Please use\
    \ @\"microsoft.quantum.math.sinh\" instead. Please use @\"microsoft.quantum.math.sinh\"\
    .", uid: Microsoft.Quantum.Extensions.Math.Sinh}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nSqrt has been deprecated. Please use\
    \ @\"microsoft.quantum.math.sqrt\" instead. Please use @\"microsoft.quantum.math.sqrt\"\
    .", uid: Microsoft.Quantum.Extensions.Math.Sqrt}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nTan has been deprecated. Please use @\"\
    microsoft.quantum.math.tan\" instead. Please use @\"microsoft.quantum.math.tan\"\
    .", uid: Microsoft.Quantum.Extensions.Math.Tan}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nTanh has been deprecated. Please use\
    \ @\"microsoft.quantum.math.tanh\" instead. Please use @\"microsoft.quantum.math.tanh\"\
    .", uid: Microsoft.Quantum.Extensions.Math.Tanh}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nTruncate has been deprecated. Please\
    \ use @\"microsoft.quantum.math.truncate\" instead. Please use @\"microsoft.quantum.math.truncate\"\
    .", uid: Microsoft.Quantum.Extensions.Math.Truncate}
- {summary: Logs a message., uid: Microsoft.Quantum.Intrinsic.Message}
- {summary: Returns the Boolean conjunction of two values., uid: Microsoft.Quantum.Logical.And}
- {summary: 'Returns one of two values, depending on the value of a Boolean condition.',
  uid: Microsoft.Quantum.Logical.Conditioned}
- {summary: Returns true if and only if two inputs are equal., uid: Microsoft.Quantum.Logical.EqualB}
- {summary: Returns true if and only if two inputs are equal., uid: Microsoft.Quantum.Logical.EqualC}
- {summary: Returns true if and only if two inputs are equal., uid: Microsoft.Quantum.Logical.EqualCP}
- {summary: Returns true if and only if two inputs are equal., uid: Microsoft.Quantum.Logical.EqualD}
- {summary: Returns true if and only if two inputs are equal., uid: Microsoft.Quantum.Logical.EqualI}
- {summary: Returns true if and only if two inputs are equal., uid: Microsoft.Quantum.Logical.EqualL}
- {summary: Returns true if and only if two inputs are equal., uid: Microsoft.Quantum.Logical.EqualR}
- {summary: Returns true if and only if a number is greater than another number.,
  uid: Microsoft.Quantum.Logical.GreaterThanD}
- {summary: Returns true if and only if a number is greater than another number.,
  uid: Microsoft.Quantum.Logical.GreaterThanI}
- {summary: Returns true if and only if a number is greater than another number.,
  uid: Microsoft.Quantum.Logical.GreaterThanL}
- {summary: Returns true if and only if a number is greater than or equal to another
    number., uid: Microsoft.Quantum.Logical.GreaterThanOrEqualD}
- {summary: Returns true if and only if a number is greater than or equal to another
    number., uid: Microsoft.Quantum.Logical.GreaterThanOrEqualI}
- {summary: Returns true if and only if a number is greater than or equal to another
    number., uid: Microsoft.Quantum.Logical.GreaterThanOrEqualL}
- {summary: Returns true if and only if a number is less than another number., uid: Microsoft.Quantum.Logical.LessThanD}
- {summary: Returns true if and only if a number is less than another number., uid: Microsoft.Quantum.Logical.LessThanI}
- {summary: Returns true if and only if a number is less than another number., uid: Microsoft.Quantum.Logical.LessThanL}
- {summary: Used to implement `LexographicComparison`., uid: Microsoft.Quantum.Logical.LessThanLexographic}
- {summary: Returns true if and only if a number is less than or equal to another
    number., uid: Microsoft.Quantum.Logical.LessThanOrEqualD}
- {summary: Returns true if and only if a number is less than or equal to another
    number., uid: Microsoft.Quantum.Logical.LessThanOrEqualI}
- {summary: Returns true if and only if a number is less than or equal to another
    number., uid: Microsoft.Quantum.Logical.LessThanOrEqualL}
- {summary: 'Given a comparison function, returns a new function that lexographically
    compares two arrays.', uid: Microsoft.Quantum.Logical.LexographicComparison}
- {summary: 'Returns true if and only if two inputs are nearly equal (that is, within
    a tolerance of 1e-12).', uid: Microsoft.Quantum.Logical.NearlyEqualD}
- {summary: Returns the Boolean negation of a value., uid: Microsoft.Quantum.Logical.Not}
- {summary: Returns true if and only if two inputs are not equal., uid: Microsoft.Quantum.Logical.NotEqualB}
- {summary: Returns true if and only if two inputs are not equal., uid: Microsoft.Quantum.Logical.NotEqualC}
- {summary: Returns true if and only if two inputs are not equal., uid: Microsoft.Quantum.Logical.NotEqualCP}
- {summary: Returns true if and only if two inputs are not equal., uid: Microsoft.Quantum.Logical.NotEqualD}
- {summary: Returns true if and only if two inputs are not equal., uid: Microsoft.Quantum.Logical.NotEqualI}
- {summary: Returns true if and only if two inputs are not equal., uid: Microsoft.Quantum.Logical.NotEqualL}
- {summary: Returns true if and only if two inputs are not equal., uid: Microsoft.Quantum.Logical.NotEqualR}
- {summary: 'Returns true if and only if two inputs are not nearly equal (that is,
    are not within a tolerance of 1e-12).', uid: Microsoft.Quantum.Logical.NotNearlyEqualD}
- {summary: Returns the Boolean disjunction of two values., uid: Microsoft.Quantum.Logical.Or}
- {summary: Returns the Boolean exclusive disjunction of two values., uid: Microsoft.Quantum.Logical.Xor}
- {summary: 'Given a set of coefficients and a tolerance, returns a state preparation
    operation that prepares each coefficient as the corresponding amplitude of a computational
    basis state, up to the given tolerance.', uid: Microsoft.Quantum.MachineLearning.ApproximateInputEncoder}
- {summary: 'Given one or more layers of controlled rotations, returns a single layer
    with model parameter index shifted such that distinct layers are parameterized
    by distinct model parameters.', uid: Microsoft.Quantum.MachineLearning.CombinedStructure}
- {summary: 'Returns an array of singly controlled rotations along a given axis, arranged
    cyclically across a register of qubits, and parameterized by distinct model parameters.',
  uid: Microsoft.Quantum.MachineLearning.CyclicEntanglingLayer}
- {summary: Returns a default set of options for training classifiers., uid: Microsoft.Quantum.MachineLearning.DefaultTrainingOptions}
- {summary: Returns the number of qubits required to encode a particular feature vector.,
  uid: Microsoft.Quantum.MachineLearning.FeatureRegisterSize}
- {summary: 'Given a of classification probability and a bias, returns the label inferred
    from that probability.', uid: Microsoft.Quantum.MachineLearning.InferredLabel}
- {summary: 'Given an array of classification probabilities and a bias, returns the
    label inferred from each probability.', uid: Microsoft.Quantum.MachineLearning.InferredLabels}
- {summary: 'Given a set of coefficients and a tolerance, returns a state preparation
    operation that prepares each coefficient as the corresponding amplitude of a computational
    basis state.', uid: Microsoft.Quantum.MachineLearning.InputEncoder}
- {summary: 'Returns an array of uncontrolled (single-qubit) rotations along a given
    axis, with one rotation for each qubit in a register, parameterized by distinct
    model parameters.', uid: Microsoft.Quantum.MachineLearning.LocalRotationsLayer}
- {summary: 'Given a set of inferred labels and a set of correct labels, returns indices
    for where each set of labels differs.', uid: Microsoft.Quantum.MachineLearning.Misclassifications}
- {summary: 'Given a set of inferred labels and a set of correct labels, returns the
    number of indices at which each set of labels differ.', uid: Microsoft.Quantum.MachineLearning.NMisclassifications}
- {summary: Returns the number of qubits required to apply a given sequential classifier.,
  uid: Microsoft.Quantum.MachineLearning.NQubitsRequired}
- {summary: 'Returns an array of single-qubit rotations along a given axis, parameterized
    by distinct model parameters.', uid: Microsoft.Quantum.MachineLearning.PartialRotationsLayer}
- {summary: 'Samples a given array, using the given schedule.', uid: Microsoft.Quantum.MachineLearning.Sampled}
- {summary: Returns the number of elements in a given sampling schedule., uid: Microsoft.Quantum.MachineLearning.ScheduleLength}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._AllNearlyEqualD}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._CallFlipped}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._CanApplyTwoQubitCase}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._EncodeSample}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._Features}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._Flipped}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._Label}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._MisclassificationRate}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._NegativeLocations}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._TailMeasurement}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._UncontrolledSpanSequence}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._Unnegate}
- {summary: Returns a bias value that leads to near-minimum misclassification score.,
  uid: Microsoft.Quantum.MachineLearning._UpdatedBias}
- {summary: Returns the absolute value of a complex number of type `Complex`., uid: Microsoft.Quantum.Math.AbsComplex}
- {summary: Returns the absolute value of a complex number of type `ComplexPolar`.,
  uid: Microsoft.Quantum.Math.AbsComplexPolar}
- {summary: Returns the absolute value of a double-precision floating-point number.,
  uid: Microsoft.Quantum.Math.AbsD}
- {summary: Returns the absolute value of an integer., uid: Microsoft.Quantum.Math.AbsI}
- {summary: Returns the absolute value of a big integer., uid: Microsoft.Quantum.Math.AbsL}
- {summary: Returns the squared absolute value of a complex number of type `Complex`.,
  uid: Microsoft.Quantum.Math.AbsSquaredComplex}
- {summary: Returns the squared absolute value of a complex number of type `ComplexPolar`.,
  uid: Microsoft.Quantum.Math.AbsSquaredComplexPolar}
- {summary: Helper function used to recursively calculate the bitsize of a value.,
  uid: Microsoft.Quantum.Math.AccumulatedBitsizeI}
- {summary: Helper function used to recursively calculate the bitsize of a value.,
  uid: Microsoft.Quantum.Math.AccumulatedBitsizeL}
- {summary: Returns the angle whose cosine is the specified number., uid: Microsoft.Quantum.Math.ArcCos}
- {summary: Computes the inverse hyperbolic cosine of a number., uid: Microsoft.Quantum.Math.ArcCosh}
- {summary: Returns the angle whose sine is the specified number., uid: Microsoft.Quantum.Math.ArcSin}
- {summary: Computes the inverse hyperbolic sine of a number., uid: Microsoft.Quantum.Math.ArcSinh}
- {summary: Returns the angle whose tangent is the specified number., uid: Microsoft.Quantum.Math.ArcTan}
- {summary: Returns the angle whose tangent is the quotient of two specified numbers.,
  uid: Microsoft.Quantum.Math.ArcTan2}
- {summary: Computes the inverse hyperbolic tangent of a number., uid: Microsoft.Quantum.Math.ArcTanh}
- {summary: Returns the phase of a complex number of type `Complex`., uid: Microsoft.Quantum.Math.ArgComplex}
- {summary: Returns the phase of a complex number of type `ComplexPolar`., uid: Microsoft.Quantum.Math.ArgComplexPolar}
- {summary: "For a non-negative integer `a`, returns the number of bits required to\
    \ represent `a`.\nThat is, returns the smallest $n$ such that $a < 2^n$.", uid: Microsoft.Quantum.Math.BitSizeI}
- {summary: "For a non-negative integer `a`, returns the number of bits required to\
    \ represent `a`.\nThat is, returns the smallest $n$ such that $a < 2^n$.", uid: Microsoft.Quantum.Math.BitSizeL}
- {summary: Returns the smallest integer greater than or equal to the specified number.,
  uid: Microsoft.Quantum.Math.Ceiling}
- {summary: Converts a complex number of type `Complex` to a complex number of type
    `ComplexPolar`., uid: Microsoft.Quantum.Math.ComplexAsComplexPolar}
- {summary: Converts a complex number of type `ComplexPolar` to a complex number of
    type `Complex`., uid: Microsoft.Quantum.Math.ComplexPolarAsComplex}
- {summary: Finds the continued fraction convergent closest to `fraction` with the
    denominator less or equal to `denominatorBound`, uid: Microsoft.Quantum.Math.ContinuedFractionConvergentI}
- {summary: Finds the continued fraction convergent closest to `fraction` with the
    denominator less or equal to `denominatorBound`, uid: Microsoft.Quantum.Math.ContinuedFractionConvergentL}
- {summary: Returns the cosine of the specified angle., uid: Microsoft.Quantum.Math.Cos}
- {summary: Returns the hyperbolic cosine of the specified angle., uid: Microsoft.Quantum.Math.Cosh}
- {summary: 'Divides one BigInteger value by another, returns the result and the remainder
    as a tuple.', uid: Microsoft.Quantum.Math.DivRemL}
- {summary: Returns the quotient of two inputs., uid: Microsoft.Quantum.Math.DividedByC}
- {summary: Returns the quotient of two inputs., uid: Microsoft.Quantum.Math.DividedByCP}
- {summary: Returns the quotient of two inputs., uid: Microsoft.Quantum.Math.DividedByD}
- {summary: Returns the quotient of two inputs., uid: Microsoft.Quantum.Math.DividedByI}
- {summary: Returns the quotient of two inputs., uid: Microsoft.Quantum.Math.DividedByL}
- {summary: Returns the natural logarithmic base $e$., uid: Microsoft.Quantum.Math.E}
- {summary: Returns $e$ raised to the specified power., uid: Microsoft.Quantum.Math.ExpD}
- {summary: 'Returns an integer raised to a given power, with respect to a given modulus.',
  uid: Microsoft.Quantum.Math.ExpModI}
- {summary: 'Returns an integer raised to a given power, with respect to a given modulus.',
  uid: Microsoft.Quantum.Math.ExpModL}
- {summary: 'Computes a tuple $(u,v)$ such that $u \cdot a + v \cdot b = \operatorname{GCD}(a,
    b)$, where $\operatorname{GCD}$ is $a$ greatest common divisor of $a$ and $b$.
    The GCD is always positive.', uid: Microsoft.Quantum.Math.ExtendedGreatestCommonDivisorI}
- {summary: 'Computes a tuple $(u,v)$ such that $u \cdot a + v \cdot b = \operatorname{GCD}(a,
    b)$, where $\operatorname{GCD}$ is $a$ greatest common divisor of $a$ and $b$.
    The GCD is always positive.', uid: Microsoft.Quantum.Math.ExtendedGreatestCommonDivisorL}
- {summary: Returns the largest integer less than or equal to the specified number.,
  uid: Microsoft.Quantum.Math.Floor}
- {summary: Computes the greatest common divisor of $a$ and $b$. The GCD is always
    positive., uid: Microsoft.Quantum.Math.GreatestCommonDivisorI}
- {summary: Computes the greatest common divisor of $a$ and $b$. The GCD is always
    positive., uid: Microsoft.Quantum.Math.GreatestCommonDivisorL}
- {summary: Returns the remainder resulting from the division of a specified number
    by another specified number., uid: Microsoft.Quantum.Math.IEEERemainder}
- {summary: 'Returns $b$ such that $a \cdot b = 1 (\operatorname{mod} \texttt{modulus})$.',
  uid: Microsoft.Quantum.Math.InverseModI}
- {summary: 'Returns $b$ such that $a \cdot b = 1 (\operatorname{mod} \texttt{modulus})$.',
  uid: Microsoft.Quantum.Math.InverseModL}
- {summary: Returns true if $a$ and $b$ are co-prime and false otherwise., uid: Microsoft.Quantum.Math.IsCoprimeI}
- {summary: Returns true if $a$ and $b$ are co-prime and false otherwise., uid: Microsoft.Quantum.Math.IsCoprimeL}
- {summary: Computes the base-2 logarithm of a number., uid: Microsoft.Quantum.Math.Lg}
- {summary: Returns the natural (base $e$) logarithm of a specified number., uid: Microsoft.Quantum.Math.Log}
- {summary: Returns the base 10 logarithm of a specified number., uid: Microsoft.Quantum.Math.Log10}
- {summary: Returns the natural logarithm of 2., uid: Microsoft.Quantum.Math.LogOf2}
- {summary: 'Given an array of integers, returns the largest element.', uid: Microsoft.Quantum.Math.Max}
- {summary: Returns the larger of two specified numbers., uid: Microsoft.Quantum.Math.MaxD}
- {summary: Returns the larger of two specified numbers., uid: Microsoft.Quantum.Math.MaxI}
- {summary: Returns the larger of two specified numbers., uid: Microsoft.Quantum.Math.MaxL}
- {summary: 'Given an array of integers, returns the smallest element.', uid: Microsoft.Quantum.Math.Min}
- {summary: Returns the smaller of two specified numbers., uid: Microsoft.Quantum.Math.MinD}
- {summary: Returns the smaller of two specified numbers., uid: Microsoft.Quantum.Math.MinI}
- {summary: Returns the smaller of two specified numbers., uid: Microsoft.Quantum.Math.MinL}
- {summary: Returns the difference between two inputs., uid: Microsoft.Quantum.Math.MinusC}
- {summary: Returns the difference between two inputs., uid: Microsoft.Quantum.Math.MinusCP}
- {summary: Returns the difference between two inputs., uid: Microsoft.Quantum.Math.MinusD}
- {summary: Returns the difference between two inputs., uid: Microsoft.Quantum.Math.MinusI}
- {summary: Returns the difference between two inputs., uid: Microsoft.Quantum.Math.MinusL}
- {summary: Returns the modulus of a number with respect to another number., uid: Microsoft.Quantum.Math.ModI}
- {summary: Returns the modulus of a number with respect to another number., uid: Microsoft.Quantum.Math.ModL}
- {summary: Performs modular division on a number raised to the power of another number.,
  uid: Microsoft.Quantum.Math.ModPowL}
- {summary: Computes the canonical residue of `value` modulo `modulus`., uid: Microsoft.Quantum.Math.ModulusI}
- {summary: Computes the canonical residue of `value` modulo `modulus`., uid: Microsoft.Quantum.Math.ModulusL}
- {summary: Returns the unary negation of an input., uid: Microsoft.Quantum.Math.NegationC}
- {summary: Returns the unary negation of an input., uid: Microsoft.Quantum.Math.NegationCP}
- {summary: Returns the unary negation of an input., uid: Microsoft.Quantum.Math.NegationD}
- {summary: Returns the unary negation of an input., uid: Microsoft.Quantum.Math.NegationI}
- {summary: Returns the unary negation of an input., uid: Microsoft.Quantum.Math.NegationL}
- {summary: "Represents the ratio of the circumference of a circle to its diameter,\
    \ specified by the constant, \u03C0.", uid: Microsoft.Quantum.Math.PI}
- {summary: "Returns the `L(p)` norm of a vector of `Double`s.\nThat is, given an\
    \ array $x$ of type `Double[]`, this returns the $p$-norm $\\|x\\|\\_p= (\\sum_{j}|x_j|^{p})^{1/p}$.",
  uid: Microsoft.Quantum.Math.PNorm}
- {summary: "Normalizes a vector of `Double`s in the `L(p)` norm.\nThat is, given\
    \ an array $x$ of type `Double[]`, this returns an array where all elements are\
    \ divided by the $p$-norm $\\|x\\|_p$.", uid: Microsoft.Quantum.Math.PNormalized}
- {summary: Returns the sum (concatenation) of two inputs., uid: Microsoft.Quantum.Math.PlusA}
- {summary: Returns the sum of two inputs., uid: Microsoft.Quantum.Math.PlusC}
- {summary: Returns the sum of two inputs., uid: Microsoft.Quantum.Math.PlusCP}
- {summary: Returns the sum of two inputs., uid: Microsoft.Quantum.Math.PlusD}
- {summary: Returns the sum of two inputs., uid: Microsoft.Quantum.Math.PlusI}
- {summary: Returns the sum of two inputs., uid: Microsoft.Quantum.Math.PlusL}
- {summary: Returns a number raised to a given power., uid: Microsoft.Quantum.Math.PowC}
- {summary: 'Internal. Since it is easiest to define the power of two complex numbers
    in cartesian form as returning in polar form, we define that here, then convert
    as needed.', uid: Microsoft.Quantum.Math.PowCAsCP}
- {summary: Returns a number raised to a given power., uid: Microsoft.Quantum.Math.PowCP}
- {summary: Returns the number x raised to the power y., uid: Microsoft.Quantum.Math.PowD}
- {summary: Returns a number raised to a given power., uid: Microsoft.Quantum.Math.PowI}
- {summary: Returns a number raised to a given power., uid: Microsoft.Quantum.Math.PowL}
- {summary: Computes the modulus between two real numbers., uid: Microsoft.Quantum.Math.RealMod}
- {summary: Rounds a value to the nearest integer., uid: Microsoft.Quantum.Math.Round}
- {summary: Returns an integer that indicates the sign of a number., uid: Microsoft.Quantum.Math.SignD}
- {summary: Returns an integer that indicates the sign of a number., uid: Microsoft.Quantum.Math.SignI}
- {summary: Returns an integer that indicates the sign of a number., uid: Microsoft.Quantum.Math.SignL}
- {summary: Returns the sine of the specified angle., uid: Microsoft.Quantum.Math.Sin}
- {summary: Returns the hyperbolic sine of the specified angle., uid: Microsoft.Quantum.Math.Sinh}
- {summary: Returns the square root of a specified number., uid: Microsoft.Quantum.Math.Sqrt}
- {summary: Returns the squared 2-norm of a vector., uid: Microsoft.Quantum.Math.SquaredNorm}
- {summary: Returns the tangent of the specified angle., uid: Microsoft.Quantum.Math.Tan}
- {summary: Returns the hyperbolic tangent of the specified angle., uid: Microsoft.Quantum.Math.Tanh}
- {summary: Returns the product of two inputs., uid: Microsoft.Quantum.Math.TimesC}
- {summary: Returns the product of two inputs., uid: Microsoft.Quantum.Math.TimesCP}
- {summary: Returns the product of two inputs., uid: Microsoft.Quantum.Math.TimesD}
- {summary: Returns the product of two inputs., uid: Microsoft.Quantum.Math.TimesI}
- {summary: Returns the product of two inputs., uid: Microsoft.Quantum.Math.TimesL}
- {summary: Calculates the integral part of a number., uid: Microsoft.Quantum.Math.Truncate}
- {summary: Internal recursive call to calculate the GCD with a bound, uid: Microsoft.Quantum.Math._ContinuedFractionConvergentI}
- {summary: Internal recursive call to calculate the GCD with a bound, uid: Microsoft.Quantum.Math._ContinuedFractionConvergentL}
- {summary: Internal recursive call to calculate the GCD., uid: Microsoft.Quantum.Math._ExtendedGreatestCommonDivisorI}
- {summary: Internal recursive call to calculate the GCD., uid: Microsoft.Quantum.Math._ExtendedGreatestCommonDivisorL}
- {summary: 'Returns the local minimum for a univariate function over a bounded interval,
    using a golden interval search.', uid: Microsoft.Quantum.Optimization.LocalUnivariateMinimum}
- {summary: Returns the midpoint for an interval., uid: Microsoft.Quantum.Optimization.Midpoint}
- {summary: 'Given an interval, returns a probe interval that contracts the given
    interval by a factor of the golden ratio.', uid: Microsoft.Quantum.Optimization.Probe}
- {summary: Returns the width of an interval., uid: Microsoft.Quantum.Optimization.Width}
- {summary: Converts an oracle of type `StateOracle` to `DeterministicStateOracle`.,
  uid: Microsoft.Quantum.Oracles.DeterministicStateOracleFromStateOracle}
- {summary: Combines the oracles `DeterministicStateOracle` and `ObliviousOracle`.,
  uid: Microsoft.Quantum.Oracles.ObliviousOracleFromDeterministicStateOracle}
- {summary: 'Given an operation representing a "black-box" oracle, returns a discrete-time
    oracle which represents the "black-box" oracle repeated multiple times.', uid: Microsoft.Quantum.Oracles.OracleToDiscrete}
- {summary: Constructs reflection about a given state from an oracle., uid: Microsoft.Quantum.Oracles.ReflectionOracleFromDeterministicStateOracle}
- {summary: Converts an oracle of type `DeterministicStateOracle` to `StateOracle`.,
  uid: Microsoft.Quantum.Oracles.StateOracleFromDeterministicStateOracle}
- {summary: "Computes the Bloch sphere coordinates for a single-qubit state.\nGiven\
    \ two complex numbers $a0, a1$ that represent the qubit state, computes coordinates\
    \ on the Bloch sphere such that $a0 \\ket{0} + a1 \\ket{1} = r e^{it}(e^{-i \\\
    phi /2}\\cos{(\\theta/2)}\\ket{0}+e^{i \\phi /2}\\sin{(\\theta/2)}\\ket{1})$.",
  uid: Microsoft.Quantum.Preparation.BlochSphereCoordinates}
- {summary: "Uses the Quantum ROM technique to represent a given density matrix.\n\
    Given a list of $N$ coefficients $\\alpha_j$, this returns a unitary $U$ that\
    \ uses the Quantum-ROM technique to prepare an approximation  $\\tilde\\rho\\\
    sum_{j=0}^{N-1}p_j\\ket{j}\\bra{j}$ of the purification of the density matrix\
    \ $\\rho=\\sum_{j=0}^{N-1}\\frac{|alpha_j|}{\\sum_k |\\alpha_k|}\\ket{j}\\bra{j}$.\
    \ In this approximation, the error $\\epsilon$ is such that $|p_j-\\frac{|alpha_j|}{\\\
    sum_k |\\alpha_k|}|\\le \\epsilon / N$ and $\\|\\tilde\\rho - \\rho\\| \\le \\\
    epsilon$. In other words, $$ \\begin{align} U\\ket{0}^{\\lceil\\log_2 N\\rceil}\\\
    ket{0}^{m}=\\sum_{j=0}^{N-1}\\sqrt{p_j} \\ket{j}\\ket{\\text{garbage}_j}. \\end{align}\
    \ $$", uid: Microsoft.Quantum.Preparation.QuantumROM}
- {summary: '', uid: Microsoft.Quantum.Preparation.QuantumROMBitStringWriterByIndex}
- {summary: Returns the total number of qubits that must be allocated to the operation
    returned by `QuantumROM`., uid: Microsoft.Quantum.Preparation.QuantumROMQubitCount}
- {summary: '', uid: Microsoft.Quantum.Preparation.RangeLength}
- {summary: '', uid: Microsoft.Quantum.Preparation.RoundedDiscretizationCoefficients}
- {summary: "Returns an operation that prepares a specific quantum state.\nThe returned\
    \ operation $U$ prepares an arbitrary quantum state $\\ket{\\psi}$ with complex\
    \ coefficients $r_j e^{i t_j}$ from the $n$-qubit computational basis state $\\\
    ket{0...0}$.\nThe action of U on a newly-allocated register is given by $$ \\\
    begin{align} U\\ket{0...0}=\\ket{\\psi}=\\frac{\\sum_{j=0}^{2^n-1}r_j e^{i t_j}\\\
    ket{j}}{\\sqrt{\\sum_{j=0}^{2^n-1}|r_j|^2}}. \\end{align} $$", uid: Microsoft.Quantum.Preparation.StatePreparationComplexCoefficients}
- {summary: "Returns an operation that prepares the given quantum state.\nThe returned\
    \ operation $U$ prepares an arbitrary quantum state $\\ket{\\psi}$ with positive\
    \ coefficients $\\alpha_j\\ge 0$ from the $n$-qubit computational basis state\
    \ $\\ket{0...0}$.\nThe action of U on a newly-allocated register is given by $$\
    \ \\begin{align} U \\ket{0\\cdots 0} = \\ket{\\psi} = \\frac{\\sum_{j=0}^{2^n-1}\\\
    alpha_j \\ket{j}}{\\sqrt{\\sum_{j=0}^{2^n-1}|\\alpha_j|^2}}. \\end{align} $$",
  uid: Microsoft.Quantum.Preparation.StatePreparationPositiveCoefficients}
- {summary: Implementation step of arbitrary state preparation procedure., uid: Microsoft.Quantum.Preparation._ApproximatelyUnprepareArbitraryStatePlan}
- {summary: '', uid: Microsoft.Quantum.Preparation._CompileApproximateArbitraryStatePreparation}
- {summary: '', uid: Microsoft.Quantum.Preparation._QuantumROMDiscretization}
- {summary: '', uid: Microsoft.Quantum.Preparation._QuantumROMQubitManager}
- {summary: Implementation step of arbitrary state preparation procedure., uid: Microsoft.Quantum.Preparation._StatePreparationSBMComputeCoefficients}
- {summary: 'Returns a discrete categorical distribution, in which the probability
    for each of a finite list of given outcomes is explicitly specified.', uid: Microsoft.Quantum.Random.CategoricalDistribution}
- {summary: Returns a uniform distribution over a given inclusive interval., uid: Microsoft.Quantum.Random.ContinuousUniformDistribution}
- {summary: Returns a uniform distribution over a given inclusive range., uid: Microsoft.Quantum.Random.DiscreteUniformDistribution}
- {summary: Returns a normal distribution with a given mean and variance., uid: Microsoft.Quantum.Random.NormalDistribution}
- {summary: Returns a normal distribution with mean 0 and variance 1., uid: Microsoft.Quantum.Random.StandardNormalDistribution}
- {summary: '', uid: Microsoft.Quantum.Random.StandardTransformation}
- {summary: 'Given a continuous distribution, returns a new distribution that transforms
    the original by a given function.', uid: Microsoft.Quantum.Random.TransformedContinuousDistribution}
- {summary: Represents a dynamical generator as a set of simulatable gates and an
    expansion in the JWOptimized basis., uid: Microsoft.Quantum.Research.Chemistry.JWOptimizedFermionEvolutionFunction}
- {summary: Converts a Hamiltonian described by `JWOptimizedHTerms` to a `GeneratorSystem`
    expressed in terms of the `GeneratorIndex` convention defined in this file., uid: Microsoft.Quantum.Research.Chemistry.JWOptimizedGeneratorSystem}
- {summary: Represents a dynamical generator as a set of simulatable gates and an
    expansion in the Pauli basis., uid: Microsoft.Quantum.Research.Chemistry.JordanWignerOptimizedFermionEvolutionSet}
- {summary: Returns optimized Trotter step operation and the parameters necessary
    to run it., uid: Microsoft.Quantum.Research.Chemistry.OptimizedTrotterStepOracle}
- {summary: Classical processing step of `ApplyDeltaParity`. This computes a list
    of control qubits for evaluating parity difference between any two PQRS... terms
    of even length., uid: Microsoft.Quantum.Research.Chemistry._DeltaParityCNOTbitstring}
- {summary: Adds two `GeneratorSystem`s to create a new `GeneratorSystem`., uid: Microsoft.Quantum.Simulation.AddGeneratorSystems}
- {summary: "Encodes an operator of interest into a `BlockEncoding`.\nThis constructs\
    \ a `BlockEncoding` unitary $U=P\\cdot V\\cdot P^\\dagger$ that encodes some operator\
    \ $H=\\sum_{j}|\\alpha_j|U_j$ of interest that is a linear combination of unitaries.\
    \ Typically, $P$ is a state preparation unitary such that $P\\ket{0}\\_a=\\sum_j\\\
    sqrt{\\alpha_j/\\|\\vec\\alpha\\|\\_2}\\ket{j}\\_a$, and $V=\\sum_{j}\\ket{j}\\\
    bra{j}\\_a\\otimes U_j$.", uid: Microsoft.Quantum.Simulation.BlockEncodingByLCU}
- {summary: "Encodes an operator of interest into a `BlockEncodingReflection`.\nThis\
    \ constructs a `BlockEncodingReflection` unitary $U=P\\cdot V\\cdot P^\\dagger$\
    \ that encodes some operator $H=\\sum_{j}|\\alpha_j|U_j$ of interest that is a\
    \ linear combination of unitaries. Typically, $P$ is a state preparation unitary\
    \ such that $P\\ket{0}\\_a\\sum_j\\sqrt{\\alpha_j/\\|\\vec\\alpha\\|\\_2}\\ket{j}\\\
    _a$, and $V=\\sum_{j}\\ket{j}\\bra{j}\\_a\\otimes U_j$.", uid: Microsoft.Quantum.Simulation.BlockEncodingReflectionByLCU}
- {summary: "Converts a `BlockEncoding` into an equivalent `BLockEncodingReflection`.\n\
    That is, given a `BlockEncoding` unitary $U$ that encodes some operator $H$ of\
    \ interest, converts it into a `BlockEncodingReflection` $U'$ that encodes the\
    \ same operator, but also satisfies $U'^\\dagger = U'$. This increases the size\
    \ of the auxiliary register of $U$ by one qubit.", uid: Microsoft.Quantum.Simulation.BlockEncodingToReflection}
- {summary: Retrieves the `GeneratorIndex` function in a `GeneratorSystem`., uid: Microsoft.Quantum.Simulation.GetGeneratorSystemFunction}
- {summary: Retrieves the number of terms in a `GeneratorSystem`., uid: Microsoft.Quantum.Simulation.GetGeneratorSystemNTerms}
- {summary: 'Returns a generator index consistent with the zero Hamiltonian, `H =
    0`, which corresponds to the identity evolution operation.', uid: Microsoft.Quantum.Simulation.IdentityGeneratorIndex}
- {summary: 'Returns a generator system consistent with the zero Hamiltonian `H =
    0`, which corresponds to the identity evolution operation.', uid: Microsoft.Quantum.Simulation.IdentityGeneratorSystem}
- {summary: Returns a time-dependent generator system consistent with the Hamiltonian
    `H(s) = 0`., uid: Microsoft.Quantum.Simulation.IdentityTimeDependentGeneratorSystem}
- {summary: Used in implementation of `PauliBlockEncoding`, uid: Microsoft.Quantum.Simulation.IdxToCoeff}
- {summary: Used in implementation of `PauliBlockEncoding`, uid: Microsoft.Quantum.Simulation.IdxToUnitary}
- {summary: Converts a integer to a single-qubit Pauli operator., uid: Microsoft.Quantum.Simulation.IntToPauli}
- {summary: Returns a `TimeDependentGeneratorSystem` representing the linear interpolation
    between two `GeneratorSystem`s., uid: Microsoft.Quantum.Simulation.InterpolateGeneratorSystems}
- {summary: Linearly interpolates between two `GeneratorSystems` according to a schedule
    parameter `s` between 0 and 1 (inclusive)., uid: Microsoft.Quantum.Simulation.InterpolateGeneratorSystemsImpl}
- {summary: 'Interpolates between two generators with a uniform schedule, returning
    an operation that applies simulated evolution under the resulting time-dependent
    generator to a qubit register.', uid: Microsoft.Quantum.Simulation.InterpolatedEvolution}
- {summary: Converts an array of integers to an array of single-qubit Pauli operators.,
  uid: Microsoft.Quantum.Simulation.IntsToPaulis}
- {summary: Multiplies the coefficient in a `GeneratorIndex`., uid: Microsoft.Quantum.Simulation.MultiplyGeneratorIndex}
- {summary: Multiplies the coefficient of all terms in a `GeneratorSystem`., uid: Microsoft.Quantum.Simulation.MultiplyGeneratorSystem}
- {summary: "Creates a block-encoding unitary for a Hamiltonian.\nThe Hamiltonian\
    \ $H=\\sum_{j}\\alpha_j P_j$ is described by a sum of Pauli terms $P_j$, each\
    \ with real coefficient $\\alpha_j$.", uid: Microsoft.Quantum.Simulation.PauliBlockEncoding}
- {summary: Extracts the coefficient of a Pauli term described by a `GeneratorIndex`.,
  uid: Microsoft.Quantum.Simulation.PauliCoefficientFromGenIdx}
- {summary: Represents a dynamical generator as a set of simulatable gates and an
    expansion in the Pauli basis., uid: Microsoft.Quantum.Simulation.PauliEvolutionFunction}
- {summary: Represents a dynamical generator as a set of simulatable gates and an
    expansion in the Pauli basis., uid: Microsoft.Quantum.Simulation.PauliEvolutionSet}
- {summary: Used in implementation of `PauliBlockEncoding`, uid: Microsoft.Quantum.Simulation.PauliLCUUnitary}
- {summary: Extracts the Pauli string and its qubit indices of a Pauli term described
    by a `GeneratorIndex`., uid: Microsoft.Quantum.Simulation.PauliStringFromGenIdx}
- {summary: Converts a block-encoding reflection into a quantum walk., uid: Microsoft.Quantum.Simulation.QuantumWalkByQubitization}
- {summary: Adds multiple `GeneratorSystem`s to create a new GeneratorSystem., uid: Microsoft.Quantum.Simulation.SumGeneratorSystems}
- {summary: "`TimeDependentSimulationAlgorithm` function that uses a Trotter\u2013\
    Suzuki decomposition to approximate a unitary operator that solves the time-dependent\
    \ Schrodinger equation.", uid: Microsoft.Quantum.Simulation.TimeDependentTrotterSimulationAlgorithm}
- {summary: "`SimulationAlgorithm` function that uses a Trotter\u2013Suzuki decomposition\
    \ to approximate the time-evolution operator _exp(-iHt)_.", uid: Microsoft.Quantum.Simulation.TrotterSimulationAlgorithm}
- {summary: "Implements a single time-step of time-evolution by the system described\
    \ in an `EvolutionGenerator` using a Trotter\u2013Suzuki decomposition.", uid: Microsoft.Quantum.Simulation.TrotterStep}
- {summary: Adds two `GeneratorSystem`s to create a new `GeneratorSystem`., uid: Microsoft.Quantum.Simulation._AddGeneratorSystems}
- {summary: 'Returns a generator system consistent with the Hamiltonian `H(s) = 0`,
    where `s` is a schedule parameter.', uid: Microsoft.Quantum.Simulation._IdentityTimeDependentGeneratorSystem}
- {summary: Multiplies the coefficient of all terms in a `GeneratorSystem`., uid: Microsoft.Quantum.Simulation._MultiplyGeneratorSystem}
- {summary: "Creates a block-encoding unitary for a Hamiltonian.\nThe Hamiltonian\
    \ $H=\\sum_{j}\\alpha_j P_j$ is described by a sum of Pauli terms $P_j$, each\
    \ with real coefficient $\\alpha_j$.", uid: Microsoft.Quantum.Simulation._PauliBlockEncoding}
- {summary: Decomposes a permutation on a variable, uid: Microsoft.Quantum.Synthesis.DecomposedOn}
- {summary: 'Encode truth table in {1,-1} coding', uid: Microsoft.Quantum.Synthesis.Encoded}
- {summary: Extends a spectrum by inverted coefficients, uid: Microsoft.Quantum.Synthesis.Extended}
- {summary: "Computes Hadamard transform of a Boolean function in {-1,1} encoding\
    \ using Yates's method", uid: Microsoft.Quantum.Synthesis.FastHadamardTransformed}
- {summary: 'Constructs a MCMTMask type as a singleton array if targets is not 0,
    otherwise returns an empty array.', uid: Microsoft.Quantum.Synthesis.GateMask}
- {summary: Computes up to two MCMT masks to transform y to x., uid: Microsoft.Quantum.Synthesis.GateMasksForAssignment}
- {summary: Returns all positions in which bits of an integer are set., uid: Microsoft.Quantum.Synthesis.IntegerBits}
- {summary: Transform mask of control and target bits to a pair of control qubits
    and target qubits, uid: Microsoft.Quantum.Synthesis.MaskToQubitsPair}
- {summary: '{-1,1} coding of a Boolean truth value', uid: Microsoft.Quantum.Synthesis.RMEncoding}
- {summary: "Adjusts truth table from array of Booleans according to number of variables\n\
    A new array is returned of length `2^numVars`, possibly requiring to extend `table`'s\
    \ size with `false` entries or truncating it to `2^numVars` elements.", uid: Microsoft.Quantum.Synthesis.SizeAdjustedTruthTable}
- {summary: Compute gate masks to synthesize permutation., uid: Microsoft.Quantum.Synthesis.TBSMain}
- {summary: 'Computes gate masks to transform perm[x] to x and updates the current
    permutation.', uid: Microsoft.Quantum.Synthesis.TBSStep}
- {summary: Collect all functions for controlled gates by folding through all variable
    indexes, uid: Microsoft.Quantum.Synthesis.TruthTablesFromPermutation}
- {summary: Decomposition logic for a single variable index, uid: Microsoft.Quantum.Synthesis.TruthTablesFromPermutationFolder}
- {summary: Update an output pattern according to gate mask., uid: Microsoft.Quantum.Synthesis.UpdatedOutputPattern}
- {summary: Update permutation based according to gate mask., uid: Microsoft.Quantum.Synthesis.UpdatedPermutation}
- {summary: Insert a 0-bit into an integer, uid: Microsoft.Quantum.Synthesis.WithZeroInsertedAt}
name: Microsoft.Quantum.Chemistry.JordanWigner.VQE
newtypes:
- {summary: Phases for a sequence of partial reflections in amplitude amplification.,
  uid: Microsoft.Quantum.AmplitudeAmplification.ReflectionPhases}
- {summary: Phases for a sequence of single-qubit rotations in amplitude amplification.,
  uid: Microsoft.Quantum.AmplitudeAmplification.RotationPhases}
- {summary: Register that encodes an unsigned integer in big-endian order. The qubit
    with index `0` encodes the highest bit of an unsigned integer., uid: Microsoft.Quantum.Arithmetic.BigEndian}
- {summary: 'Represents a register of qubits encoding a fixed-point number. Consists
    of an integer that is equal to the number of qubits to the left of the binary
    point, i.e., qubits of weight greater than or equal to 1, and a quantum register.',
  uid: Microsoft.Quantum.Arithmetic.FixedPoint}
- {summary: Register that encodes an unsigned integer in little-endian order. The
    qubit with index `0` encodes the lowest bit of an unsigned integer., uid: Microsoft.Quantum.Arithmetic.LittleEndian}
- {summary: "Little-endian unsigned integers in QFT basis.\nFor example, if $\\ket{x}$\
    \ is the little-endian encoding of the integer $x$ in the computational basis,\
    \ then $\\operatorname{QFTLE} \\ket{x}$ is the encoding of $x$ in the QFT basis.",
  uid: Microsoft.Quantum.Arithmetic.PhaseLittleEndian}
- {summary: Type of a signed integer stored in little endian (see LittleEndian).,
  uid: Microsoft.Quantum.Arithmetic.SignedLittleEndian}
- {summary: The signature type of CCNOT gate., uid: Microsoft.Quantum.Canon.CCNOTop}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nResultStack has been deprecated.", uid: Microsoft.Quantum.Canon.ResultStack}
- {summary: Format of data passed from C# to Q# to represent a term of the Hamiltonian.
    The meaning of the data represented is determined by the algorithm that receives
    it., uid: Microsoft.Quantum.Chemistry.HTerm}
- {summary: Format of data passed from C# to Q# to represent terms of the Hamiltonian.
    The meaning of the data represented is determined by the algorithm that receives
    it., uid: Microsoft.Quantum.Chemistry.JordanWigner.JWOptimizedHTerms}
- {summary: Format of data passed from C# to Q# to represent all information for Hamiltonian
    simulation. The meaning of the data represented is determined by the algorithm
    that receives it., uid: Microsoft.Quantum.Chemistry.JordanWigner.JordanWignerEncodingData}
- {summary: Format of data passed from C# to Q# to represent preparation of the initial
    state The meaning of the data represented is determined by the algorithm that
    receives it., uid: Microsoft.Quantum.Chemistry.JordanWigner.JordanWignerInputState}
- {summary: 'Function that returns `OptimizedBETermIndex` data for term `n` given
    an integer `n`, together with the number of terms in the first `Int` and the sum
    of absolute-values of all term coefficients in the `Double`.', uid: Microsoft.Quantum.Chemistry.JordanWigner.OptimizedBEGeneratorSystem}
- {summary: Term data in the optimized block-encoding algorithm., uid: Microsoft.Quantum.Chemistry.JordanWigner.OptimizedBETermIndex}
- {summary: Compiler-recognized attribute used to mark user-defined types as attributes.,
  uid: Microsoft.Quantum.Core.Attribute}
- {summary: Compiler-recognized attribute used to mark a type or callable as deprecated.,
  uid: Microsoft.Quantum.Core.Deprecated}
- {summary: Compiler-recognized attribute used to mark the entry point of an executable.,
  uid: Microsoft.Quantum.Core.EntryPoint}
- {summary: Compiler-recognized attribute via which an alternative name can be defined
    that may be used when loading a type or callable for testing purposes., uid: Microsoft.Quantum.Diagnostics.EnableTestingViaName}
- {summary: Compiler-recognized attribute used to mark a unit test., uid: Microsoft.Quantum.Diagnostics.Test}
- {summary: "Represents a Calderbank\u2013Shor\u2013Steane (CSS) code as defined by\
    \ its encoder, decoder, and its syndrome measurement procedures for `X` and `Z`\
    \ errors, respectively.", uid: Microsoft.Quantum.ErrorCorrection.CSS}
- {summary: "Represents an operation which decodes an encoded register into a physical\
    \ register and the scratch qubits used to record a syndrome.\nThe argument to\
    \ a DecodeOp is the same as the return from an EncodeOp, and vice versa.", uid: Microsoft.Quantum.ErrorCorrection.DecodeOp}
- {summary: "Represents an operation which encodes a physical register into a logical\
    \ register, using the provided scratch qubits.\nThe first argument is taken to\
    \ be the physical register that will be encoded, while the second argument is\
    \ taken to be the scratch register that will be used.", uid: Microsoft.Quantum.ErrorCorrection.EncodeOp}
- {summary: 'Type for register of physical qubits `Qubit[]` that encode the logical
    qubits.', uid: Microsoft.Quantum.ErrorCorrection.LogicalRegister}
- {summary: 'Represents an error-correcting code as defined by its encoder, decoder,
    and syndrome measurement procedure.', uid: Microsoft.Quantum.ErrorCorrection.QECC}
- {summary: 'Type for function that maps an error syndrome to a sequence of `Pauli[]`
    operations that correct the detected error.', uid: Microsoft.Quantum.ErrorCorrection.RecoveryFn}
- {summary: 'Type for measurement results `Result[]` that specify an error syndrome
    of a quantum code.', uid: Microsoft.Quantum.ErrorCorrection.Syndrome}
- {summary: Represents an operation that is used to measure the syndrome of an error-correcting
    code block., uid: Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp}
- {summary: 'Describes a controlled rotation in terms of its target and control indices,
    rotation axis, and index into a model parameter vector.', uid: Microsoft.Quantum.MachineLearning.ControlledRotation}
- {summary: 'A sample, labeled with a class to which that sample belongs.', uid: Microsoft.Quantum.MachineLearning.LabeledSample}
- {summary: A schedule for drawing batches from a set of samples., uid: Microsoft.Quantum.MachineLearning.SamplingSchedule}
- {summary: 'Describes a quantum classifier model composed of a sequence of parameterized
    and controlled rotations, an assignment of rotation angles, and a bias between
    the two classes recognized by the model.', uid: Microsoft.Quantum.MachineLearning.SequentialModel}
- {summary: Describes an operation that prepares a given input to a sequential classifier.,
  uid: Microsoft.Quantum.MachineLearning.StateGenerator}
- {summary: A collection of options to be used in training quantum classifiers., uid: Microsoft.Quantum.MachineLearning.TrainingOptions}
- {summary: The results from having validated a classifier against a set of samples.,
  uid: Microsoft.Quantum.MachineLearning.ValidationResults}
- {summary: Represents a rational number of the form `p/q`. Integer `p` is the first
    element of the tuple and `q` is the second element of the tuple., uid: Microsoft.Quantum.Math.BigFraction}
- {summary: 'Represents a complex number by its real and imaginary components. The
    first element of the tuple is the real component, the second one - the imaginary
    component.', uid: Microsoft.Quantum.Math.Complex}
- {summary: "Represents a complex number in polar form.\nThe polar representation\
    \ of a complex number is $c=r e^{i t}$.", uid: Microsoft.Quantum.Math.ComplexPolar}
- {summary: Represents a rational number of the form `p/q`. Integer `p` is the first
    element of the tuple and `q` is the second element of the tuple., uid: Microsoft.Quantum.Math.Fraction}
- {summary: Represents the result of optimizing a univariate function., uid: Microsoft.Quantum.Optimization.UnivariateOptimizationResult}
- {summary: "Represents a continuous-time oracle.\nThis is an oracle that implements\
    \ $U(\\delta t) : \\ket{\\psi(t)} \\mapsto \\ket{\\psi(t + \\delta t)}$ for all\
    \ times $t$, where $U$ is a fixed operation, and where $\\delta t$ is a non-negative\
    \ real number.", uid: Microsoft.Quantum.Oracles.ContinuousOracle}
- {summary: "Represents an oracle for deterministic state preparation.\nThe input\
    \ to the oracle $O$ is:\n- The register that will store the desired quantum state\
    \ $\\ket{\\psi}\\_s$.", uid: Microsoft.Quantum.Oracles.DeterministicStateOracle}
- {summary: "Represents a discrete-time oracle.\nThis is an oracle that implements\
    \ $U^m$ for a fixed operation $U$ and a non-negative integer $m$.", uid: Microsoft.Quantum.Oracles.DiscreteOracle}
- {summary: "Represents an oracle for oblivious amplitude amplification.\nThe inputs\
    \ to the oracle $O$ are:\n- The ancilla register $a$ that $O$ acts on. - The system\
    \ register $s$ on which the desired unitary $U$ is applied, post-selected on register\
    \ $a$ being in state $\\ket{t}\\_a$.", uid: Microsoft.Quantum.Oracles.ObliviousOracle}
- {summary: "Represents a reflection oracle.\nA reflection oracle, $O$, has inputs:\n\
    - The phase $\\phi$ by which to rotate the reflected subspace. - The qubit register\
    \ on which to perform the given reflection.", uid: Microsoft.Quantum.Oracles.ReflectionOracle}
- {summary: "Represents an oracle for state preparation.\nThe inputs to the oracle\
    \ $O$ are:\n- An integer indexing the flag qubit $f$. - The system register $s$\
    \ that will store the desired quantum state $\\ket{\\psi}\\_s$.", uid: Microsoft.Quantum.Oracles.StateOracle}
- {summary: Represents a univariate probability distribution over integers of arbitrary
    size., uid: Microsoft.Quantum.Random.BigDiscreteDistribution}
- {summary: Represents a univariate probability distribution over complex numbers.,
  uid: Microsoft.Quantum.Random.ComplexDistribution}
- {summary: Represents a univariate probability distribution over real numbers., uid: Microsoft.Quantum.Random.ContinuousDistribution}
- {summary: Represents a univariate probability distribution over integers., uid: Microsoft.Quantum.Random.DiscreteDistribution}
- {summary: "Represents a unitary where an arbitrary operator of interest is encoded\
    \ in the top-left block.\nThat is, a `BlockEncoding` is a unitary $U$ where an\
    \ arbitrary operator $H$ of interest that acts on the system register `s` is encoded\
    \ in the top- left block corresponding to auxiliary state $\\ket{0}_a$. That is,\n\
    $$ \\begin{align} (\\bra{0}_a\\otimes I_s)U(\\ket{0}_a\\otimes I_s) = H \\end{align}\
    \ $$.", uid: Microsoft.Quantum.Simulation.BlockEncoding}
- {summary: Represents a `BlockEncoding` that is also a reflection., uid: Microsoft.Quantum.Simulation.BlockEncodingReflection}
- {summary: "Represents a dynamical generator as a set of simulatable gates and an\
    \ expansion in terms of that basis.\nLast parameter for number of terms.", uid: Microsoft.Quantum.Simulation.EvolutionGenerator}
- {summary: "Represents a time-dependent dynamical generator.\nThe `Double` parameter\
    \ is a schedule in $[0, 1]$.", uid: Microsoft.Quantum.Simulation.EvolutionSchedule}
- {summary: "Represents a set of gates that can be readily implemented and used to\
    \ implement simulation algorithms.\nElements in the set are indexed by a  <xref:microsoft.quantum.simulation.generatorindex>,\
    \ and each set is described by a function from `GeneratorIndex` to  <xref:microsoft.quantum.simulation.evolutionunitary>,\
    \ which are operations parameterized by a real number representing time", uid: Microsoft.Quantum.Simulation.EvolutionSet}
- {summary: "Represents a unitary time-evolution operator.\nThe first parameter is\
    \ is duration of time-evolution, and the second parameter is the qubit register\
    \ acted upon by the unitary.", uid: Microsoft.Quantum.Simulation.EvolutionUnitary}
- {summary: "Represents a single primitive term in the set of all dynamical generators,\
    \ e.g. Hermitian operators, for which there exists a map from that generator to\
    \ time-evolution by that generator, through `EvolutionSet`.\nThe first element\
    \ (Int[], Double[]) is indexes that single term -- For instance, the Pauli string\
    \ XXY with coefficient 0.5 would be indexed by ([1,1,2], [0.5]). Alternatively,\
    \ Hamiltonians parameterized by a continuous variable, such as X cos \u03C6 +\
    \ Y sin \u03C6, might for instance be represented by ([], [\u03C6]). The second\
    \ element indexes the subsystem on which the generator acts on.", uid: Microsoft.Quantum.Simulation.GeneratorIndex}
- {summary: "Represents a collection of `GeneratorIndex`es.\nWe iterate over this\
    \ collection using a single-index integer, and the size of the collection is assumed\
    \ to be known.", uid: Microsoft.Quantum.Simulation.GeneratorSystem}
- {summary: "Represents a time-independent simulation algorithm.\nA time-independent\
    \ simulation technique converts an <xref:microsoft.quantum.simulation.evolutiongenerator>\
    \ to unitary time evolution for some time-interval.", uid: Microsoft.Quantum.Simulation.SimulationAlgorithm}
- {summary: "Represents a `BlockEncoding` that is controlled by a clock register.\n\
    That is, a `TimeDependentBlockEncoding` is a unitary $U$ controlled by a state\
    \ $\\ket{k}_d$ in clock register `d` such that an arbitrary operator $H_k$ of\
    \ interest that acts on the system register `s` is encoded in the top- left block\
    \ corresponding to auxiliary state $\\ket{0}_a$. That is,\n$$ \\begin{align} (\\\
    bra{0}\\_a\\otimes I_{ds})U(\\ket{0}\\_a\\otimes I_{ds}) = \\sum_{k}\\ket{k}\\\
    bra{k}\\_d\\otimes H_k. \\end{align} $$.", uid: Microsoft.Quantum.Simulation.TimeDependentBlockEncoding}
- {summary: Represents a time-dependent dynamical generator as a function from time
    to the value of the dynamical generator at that time., uid: Microsoft.Quantum.Simulation.TimeDependentGeneratorSystem}
- {summary: "Represents a time-dependent simulation algorithm.\nA time-dependent simulation\
    \ technique converts an <xref:microsoft.quantum.simulation.evolutionschedule>\
    \ to unitary time-evolution for some time-interval.", uid: Microsoft.Quantum.Simulation.TimeDependentSimulationAlgorithm}
- {summary: Represents evolution under a unitary operator., uid: Microsoft.Quantum.Simulation.Unitary}
- {summary: State during decomposition based on variable indexes, uid: Microsoft.Quantum.Synthesis.DecompositionState}
- {summary: "A type to represent a multiple-controlled multiple-target Toffoli gate.\n\
    The first integer is a bit mask for control lines.  Bit indexes which are set\
    \ correspond to control line indexes.\nThe second integer is a bit mask for target\
    \ lines.  Bit indexes which are set correspond to target line indexes.\nThe bit\
    \ indexes of both integers must be disjoint.", uid: Microsoft.Quantum.Synthesis.MCMTMask}
operations:
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAmpAmpRUSByOracle has been deprecated.\
    \ Please use @\"microsoft.quantum.amplitudeamplification.applyfixedpointamplification\"\
    \ instead. Please use @\"microsoft.quantum.amplitudeamplification.applyfixedpointamplification\"\
    .", uid: Microsoft.Quantum.AmplitudeAmplification.AmpAmpRUSByOracle}
- {summary: 'Applies amplitude amplification on a given register, using a given set
    of phases and oracles to reflect about the initial and final states.', uid: Microsoft.Quantum.AmplitudeAmplification.ApplyAmplitudeAmplification}
- {summary: Fixed-Point Amplitude Amplification algorithm, uid: Microsoft.Quantum.AmplitudeAmplification.ApplyFixedPointAmplification}
- {summary: Oblivious amplitude amplification by specifying partial reflections.,
  uid: Microsoft.Quantum.AmplitudeAmplification.ApplyObliviousAmplitudeAmplification}
- {summary: Implementation of <xref:microsoft.quantum.canon.targetstatereflectionoracle>.,
  uid: Microsoft.Quantum.AmplitudeAmplification.ApplyTargetStateReflectionOracle}
- {summary: Adds a classical constant to a quantum fixed-point number., uid: Microsoft.Quantum.Arithmetic.AddConstantFxP}
- {summary: Adds two fixed-point numbers stored in quantum registers., uid: Microsoft.Quantum.Arithmetic.AddFxP}
- {summary: 'Automatically chooses between addition with carry and without, depending
    on the register size of `ys`.', uid: Microsoft.Quantum.Arithmetic.AddI}
- {summary: Implements the inner addition function for the operation RippleCarryAdderTTK.
    This is the inner operation that is conjugated with the outer operation to construct
    the full adder., uid: Microsoft.Quantum.Arithmetic.ApplyInnerTTKAdder}
- {summary: Implements the inner addition function for the operation RippleCarryAdderNoCarryTTK.
    This is the inner operation that is conjugated with the outer operation to construct
    the full adder., uid: Microsoft.Quantum.Arithmetic.ApplyInnerTTKAdderWithoutCarry}
- {summary: Applies an operation that takes a <xref:microsoft.quantum.arithmetic.phaselittleendian>
    register as input on a target register of type <xref:microsoft.quantum.arithmetic.littleendian>.,
  uid: Microsoft.Quantum.Arithmetic.ApplyLEOperationOnPhaseLE}
- {summary: Applies an operation that takes a <xref:microsoft.quantum.arithmetic.phaselittleendian>
    register as input on a target register of type <xref:microsoft.quantum.arithmetic.littleendian>.,
  uid: Microsoft.Quantum.Arithmetic.ApplyLEOperationOnPhaseLEA}
- {summary: Applies an operation that takes a <xref:microsoft.quantum.arithmetic.phaselittleendian>
    register as input on a target register of type <xref:microsoft.quantum.arithmetic.littleendian>.,
  uid: Microsoft.Quantum.Arithmetic.ApplyLEOperationOnPhaseLEC}
- {summary: Applies an operation that takes a <xref:microsoft.quantum.arithmetic.phaselittleendian>
    register as input on a target register of type <xref:microsoft.quantum.arithmetic.littleendian>.,
  uid: Microsoft.Quantum.Arithmetic.ApplyLEOperationOnPhaseLECA}
- {summary: Applies the three-qubit majority operation in-place on a register of qubits.,
  uid: Microsoft.Quantum.Arithmetic.ApplyMajorityInPlace}
- {summary: 'Reversible, in-place ripple-carry operation that is used in the integer
    addition operation RippleCarryAdderCDKM below. Given two qubit registers `xs`
    and `ys` of the same length, the operation applies a ripple carry sequence of
    CNOT and CCNOT gates with qubits in `xs` and `ys` as the controls and qubits in
    `xs` as the targets.', uid: Microsoft.Quantum.Arithmetic.ApplyOuterCDKMAdder}
- {summary: Implements the outer operation for RippleCarryAdderTTK to conjugate the
    inner operation to construct the full adder., uid: Microsoft.Quantum.Arithmetic.ApplyOuterTTKAdder}
- {summary: Applies an operation that takes a <xref:microsoft.quantum.arithmetic.littleendian>
    register as input on a target register of type <xref:microsoft.quantum.arithmetic.phaselittleendian>.,
  uid: Microsoft.Quantum.Arithmetic.ApplyPhaseLEOperationOnLE}
- {summary: '', uid: Microsoft.Quantum.Arithmetic.ApplyPhaseLEOperationOnLEA}
- {summary: '', uid: Microsoft.Quantum.Arithmetic.ApplyPhaseLEOperationOnLEC}
- {summary: '', uid: Microsoft.Quantum.Arithmetic.ApplyPhaseLEOperationOnLECA}
- {summary: Applies an operation that takes big-endian input to a register encoding
    an unsigned integer using little-endian format., uid: Microsoft.Quantum.Arithmetic.ApplyReversedOpBE}
- {summary: Applies an operation that takes big-endian input to a register encoding
    an unsigned integer using little-endian format., uid: Microsoft.Quantum.Arithmetic.ApplyReversedOpBEA}
- {summary: Applies an operation that takes big-endian input to a register encoding
    an unsigned integer using little-endian format., uid: Microsoft.Quantum.Arithmetic.ApplyReversedOpBEC}
- {summary: Applies an operation that takes big-endian input to a register encoding
    an unsigned integer using little-endian format., uid: Microsoft.Quantum.Arithmetic.ApplyReversedOpBECA}
- {summary: Applies an operation that takes little-endian input to a register encoding
    an unsigned integer using big-endian format., uid: Microsoft.Quantum.Arithmetic.ApplyReversedOpLE}
- {summary: Applies an operation that takes little-endian input to a register encoding
    an unsigned integer using big-endian format., uid: Microsoft.Quantum.Arithmetic.ApplyReversedOpLEA}
- {summary: Applies an operation that takes little-endian input to a register encoding
    an unsigned integer using big-endian format., uid: Microsoft.Quantum.Arithmetic.ApplyReversedOpLEC}
- {summary: Applies an operation that takes little-endian input to a register encoding
    an unsigned integer using big-endian format., uid: Microsoft.Quantum.Arithmetic.ApplyReversedOpLECA}
- {summary: Applies a bitwise-XOR operation between a classical integer and an integer
    represented by a register of qubits., uid: Microsoft.Quantum.Arithmetic.ApplyXorInPlace}
- {summary: 'Helper function to assert that a quantum fixed-point number is initialized
    to zero, i.e., all qubits are in state $\ket{0}$.', uid: Microsoft.Quantum.Arithmetic.AssertAllZeroFxP}
- {summary: Asserts that the most significant qubit of a qubit register representing
    an unsigned integer is in a particular state., uid: Microsoft.Quantum.Arithmetic.AssertMostSignificantBit}
- {summary: Asserts that the `number` encoded in PhaseLittleEndian is less than `value`.,
  uid: Microsoft.Quantum.Arithmetic.AssertPhaseLessThan}
- {summary: Asserts that the probability of a specific state of a quantum register
    has the expected value., uid: Microsoft.Quantum.Arithmetic.AssertProbInt}
- {summary: 'Implements a reversible carry gate. Given a carry-in bit encoded in qubit
    `carryIn` and two summand bits encoded in `summand1` and `summand2`, computes
    the bitwise xor of `carryIn`, `summand1` and `summand2` in the qubit `summand2`
    and the carry-out is xored to the qubit `carryOut`.', uid: Microsoft.Quantum.Arithmetic.Carry}
- {summary: 'The core operation in the RippleCarryAdderCDKM, used with the above ApplyOuterCDKMAdder
    operation, i.e. conjugated with this operation to obtain the inner operation of
    the RippleCarryAdderCDKM. This operation computes the carry out qubit and applies
    a sequence of NOT gates on part of the input `ys`.', uid: Microsoft.Quantum.Arithmetic.CarryOutCoreCDKM}
- {summary: 'Wrapper for integer comparison: `result = x > y`.', uid: Microsoft.Quantum.Arithmetic.CompareGTI}
- {summary: 'Wrapper for signed integer comparison: `result = xs > ys`.', uid: Microsoft.Quantum.Arithmetic.CompareGTSI}
- {summary: 'Compares two fixed-point numbers stored in quantum registers, and controls
    a flip on the result.', uid: Microsoft.Quantum.Arithmetic.CompareGreaterThanFxP}
- {summary: 'This operation tests if an integer represented by a register of qubits
    is greater than another integer, applying an XOR of the result onto an output
    qubit.', uid: Microsoft.Quantum.Arithmetic.CompareUsingRippleCarry}
- {summary: Computes $1/x$ for a fixed-point number $x$., uid: Microsoft.Quantum.Arithmetic.ComputeReciprocalFxP}
- {summary: 'Computes the reciprocal 1/x for an unsigned integer x using integer division.
    The result, interpreted as an integer, will be `floor(2^(2*n-1) / x)`.', uid: Microsoft.Quantum.Arithmetic.ComputeReciprocalI}
- {summary: Copies the most significant bit of a qubit register `from` representing
    an unsigned integer into the qubit `target`., uid: Microsoft.Quantum.Arithmetic.CopyMostSignificantBit}
- {summary: Divides two quantum integers., uid: Microsoft.Quantum.Arithmetic.DivideI}
- {summary: Evaluates an even polynomial in a fixed-point representation., uid: Microsoft.Quantum.Arithmetic.EvaluateEvenPolynomialFxP}
- {summary: Evaluates an odd polynomial in a fixed-point representation., uid: Microsoft.Quantum.Arithmetic.EvaluateOddPolynomialFxP}
- {summary: Evaluates a polynomial in a fixed-point representation., uid: Microsoft.Quantum.Arithmetic.EvaluatePolynomialFxP}
- {summary: 'Applies a greater-than comparison between two integers encoded into qubit
    registers, flipping a target qubit based on the result of the comparison.', uid: Microsoft.Quantum.Arithmetic.GreaterThan}
- {summary: 'Increments an unsigned quantum register by a classical integer, using
    phase rotations.', uid: Microsoft.Quantum.Arithmetic.IncrementByInteger}
- {summary: Performs a modular increment of a qubit register by an integer constant.,
  uid: Microsoft.Quantum.Arithmetic.IncrementByModularInteger}
- {summary: 'Increments an unsigned quantum register by a classical integer, using
    phase rotations.', uid: Microsoft.Quantum.Arithmetic.IncrementPhaseByInteger}
- {summary: Performs a modular increment of a qubit register by an integer constant.,
  uid: Microsoft.Quantum.Arithmetic.IncrementPhaseByModularInteger}
- {summary: Inverts a given integer modulo 2's complement., uid: Microsoft.Quantum.Arithmetic.Invert2sSI}
- {summary: This applies the in-place majority operation to 3 qubits., uid: Microsoft.Quantum.Arithmetic.MAJ}
- {summary: 'Measure a fixed-point number, returns its value as Double, and resets
    all the register to zero.', uid: Microsoft.Quantum.Arithmetic.MeasureFxP}
- {summary: 'Measures the content of a quantum register and converts it to an integer.
    The measurement is performed with respect to the standard computational basis,
    i.e., the eigenbasis of `PauliZ`.', uid: Microsoft.Quantum.Arithmetic.MeasureInteger}
- {summary: Performs a modular multiply-and-add by integer constants on a qubit register.,
  uid: Microsoft.Quantum.Arithmetic.MultiplyAndAddByModularInteger}
- {summary: 'The same as MultiplyAndAddByModularInteger, but assumes that the summand
    encodes integers in QFT basis.', uid: Microsoft.Quantum.Arithmetic.MultiplyAndAddPhaseByModularInteger}
- {summary: Performs modular multiplication by an integer constant on a qubit register.,
  uid: Microsoft.Quantum.Arithmetic.MultiplyByModularInteger}
- {summary: Multiplies two fixed-point numbers in quantum registers., uid: Microsoft.Quantum.Arithmetic.MultiplyFxP}
- {summary: 'Multiply integer `xs` by integer `ys` and store the result in `result`,
    which must be zero initially.', uid: Microsoft.Quantum.Arithmetic.MultiplyI}
- {summary: 'Multiply signed integer `xs` by signed integer `ys` and store the result
    in `result`, which must be zero initially.', uid: Microsoft.Quantum.Arithmetic.MultiplySI}
- {summary: Initialize a quantum fixed-point number to a classical constant., uid: Microsoft.Quantum.Arithmetic.PrepareFxP}
- {summary: Reflects a quantum register about a given classical integer., uid: Microsoft.Quantum.Arithmetic.ReflectAboutInteger}
- {summary: 'Reversible, in-place ripple-carry addition of two integers.', uid: Microsoft.Quantum.Arithmetic.RippleCarryAdderCDKM}
- {summary: 'Reversible, in-place ripple-carry addition of two integers. Given two
    $n$-bit integers encoded in LittleEndian registers `xs` and `ys`, and a qubit
    carry, the operation computes the sum of the two integers where the $n$ least
    significant bits of the result are held in `ys` and the carry out bit is xored
    to the qubit `carry`.', uid: Microsoft.Quantum.Arithmetic.RippleCarryAdderD}
- {summary: 'Reversible, in-place ripple-carry addition of two integers without carry
    out.', uid: Microsoft.Quantum.Arithmetic.RippleCarryAdderNoCarryTTK}
- {summary: 'Reversible, in-place ripple-carry addition of two integers. Given two
    $n$-bit integers encoded in LittleEndian registers `xs` and `ys`, and a qubit
    carry, the operation computes the sum of the two integers where the $n$ least
    significant bits of the result are held in `ys` and the carry out bit is xored
    to the qubit `carry`.', uid: Microsoft.Quantum.Arithmetic.RippleCarryAdderTTK}
- {summary: Squares a fixed-point number., uid: Microsoft.Quantum.Arithmetic.SquareFxP}
- {summary: 'Computes the square of the integer `xs` into `result`, which must be
    zero initially.', uid: Microsoft.Quantum.Arithmetic.SquareI}
- {summary: 'Square signed integer `xs` and store the result in `result`, which must
    be zero initially.', uid: Microsoft.Quantum.Arithmetic.SquareSI}
- {summary: 'Implements a reversible sum gate. Given a carry-in bit encoded in qubit
    `carryIn` and two summand bits encoded in `summand1` and `summand2`, computes
    the bitwise xor of `carryIn`, `summand1` and `summand2` in the qubit `summand2`.',
  uid: Microsoft.Quantum.Arithmetic.Sum}
- {summary: 'Repeats an operation for a given number of samples, collecting its outputs
    in an array.', uid: Microsoft.Quantum.Arrays.DrawMany}
- {summary: 'Given an array and an operation that is defined for the elements of the
    array, returns a new array that consists of the images of the original array under
    the operation.', uid: Microsoft.Quantum.Arrays.ForEach}
- {summary: Performs a controlled "AND ladder" on a register of target qubits., uid: Microsoft.Quantum.Canon.AndLadder}
- {summary: 'Inverts a given target qubit if and only if both control qubits are in
    the 1 state, using measurement to perform the adjoint operation.', uid: Microsoft.Quantum.Canon.ApplyAnd}
- {summary: '', uid: Microsoft.Quantum.Canon.ApplyBound}
- {summary: '', uid: Microsoft.Quantum.Canon.ApplyBoundA}
- {summary: '', uid: Microsoft.Quantum.Canon.ApplyBoundC}
- {summary: '', uid: Microsoft.Quantum.Canon.ApplyBoundCA}
- {summary: 'Implements a cascade of CCNOT gates controlled on corresponding bits
    of two qubit registers, acting on the next qubit of one of the registers. Starting
    from the qubits at position 0 in both registers as controls, CCNOT is applied
    to the qubit at position 1 of the target register, then controlled by the qubits
    at position 1 acting on the qubit at position 2 in the target register, etc.,
    ending with an action on the target qubit in position `Length(nQubits)-1`.', uid: Microsoft.Quantum.Canon.ApplyCCNOTChain}
- {summary: Computes the parity of a register of qubits in-place., uid: Microsoft.Quantum.Canon.ApplyCNOTChain}
- {summary: Computes the parity of an array of qubits into a target qubit., uid: Microsoft.Quantum.Canon.ApplyCNOTChainWithTarget}
- {summary: 'Applies a unitary operation on the target register, controlled on a a
    state specified by a given bit mask.', uid: Microsoft.Quantum.Canon.ApplyControlledOnBitString}
- {summary: Applies a unitary operation on the target register if the control register
    state corresponds to a specified positive integer., uid: Microsoft.Quantum.Canon.ApplyControlledOnInt}
- {summary: '', uid: Microsoft.Quantum.Canon.ApplyCurriedOp}
- {summary: '', uid: Microsoft.Quantum.Canon.ApplyCurriedOpA}
- {summary: '', uid: Microsoft.Quantum.Canon.ApplyCurriedOpC}
- {summary: '', uid: Microsoft.Quantum.Canon.ApplyCurriedOpCA}
- {summary: Applies an array of complex phases to numeric basis states of a register
    of qubits., uid: Microsoft.Quantum.Canon.ApplyDiagonalUnitary}
- {summary: Applies the Fermionic SWAP., uid: Microsoft.Quantum.Canon.ApplyFermionicSWAP}
- {summary: Applies an operation conditioned on a classical bit., uid: Microsoft.Quantum.Canon.ApplyIf}
- {summary: Applies a adjointable operation conditioned on a classical bit., uid: Microsoft.Quantum.Canon.ApplyIfA}
- {summary: Applies a controllable operation conditioned on a classical bit., uid: Microsoft.Quantum.Canon.ApplyIfC}
- {summary: Applies a unitary operation conditioned on a classical bit., uid: Microsoft.Quantum.Canon.ApplyIfCA}
- {summary: 'Applies one of two operations, depending on the value of a classical
    bit.', uid: Microsoft.Quantum.Canon.ApplyIfElseB}
- {summary: 'Applies one of two adjointable operations, depending on the value of
    a classical bit.', uid: Microsoft.Quantum.Canon.ApplyIfElseBA}
- {summary: 'Applies one of two controllable operations, depending on the value of
    a classical bit.', uid: Microsoft.Quantum.Canon.ApplyIfElseBC}
- {summary: 'Applies one of two unitary operations, depending on the value of a classical
    bit.', uid: Microsoft.Quantum.Canon.ApplyIfElseBCA}
- {summary: 'Applies one of two operations, depending on the value of a classical
    result.', uid: Microsoft.Quantum.Canon.ApplyIfElseR}
- {summary: 'Applies one of two adjointable operations, depending on the value of
    a classical result.', uid: Microsoft.Quantum.Canon.ApplyIfElseRA}
- {summary: 'Applies one of two controllable operations, depending on the value of
    a classical result.', uid: Microsoft.Quantum.Canon.ApplyIfElseRC}
- {summary: 'Applies one of two unitary operations, depending on the value of a classical
    result.', uid: Microsoft.Quantum.Canon.ApplyIfElseRCA}
- {summary: Applies an operation conditioned on a classical result value being one.,
  uid: Microsoft.Quantum.Canon.ApplyIfOne}
- {summary: Applies an adjointable operation conditioned on a classical result value
    being one., uid: Microsoft.Quantum.Canon.ApplyIfOneA}
- {summary: Applies a controllable operation conditioned on a classical result value
    being one., uid: Microsoft.Quantum.Canon.ApplyIfOneC}
- {summary: Applies a unitary operation conditioned on a classical result value being
    one., uid: Microsoft.Quantum.Canon.ApplyIfOneCA}
- {summary: Applies an operation conditioned on a classical result value being zero.,
  uid: Microsoft.Quantum.Canon.ApplyIfZero}
- {summary: Applies an adjointable operation conditioned on a classical result value
    being zero., uid: Microsoft.Quantum.Canon.ApplyIfZeroA}
- {summary: Applies a controllable operation conditioned on a classical result value
    being zero., uid: Microsoft.Quantum.Canon.ApplyIfZeroC}
- {summary: Applies a unitary operation conditioned on a classical result value being
    zero., uid: Microsoft.Quantum.Canon.ApplyIfZeroCA}
- {summary: 'Inverts a given target qubit if and only if both control qubits are in
    the 1 state, with T-depth 1, using measurement to perform the adjoint operation.',
  uid: Microsoft.Quantum.Canon.ApplyLowDepthAnd}
- {summary: Applies a multiply controlled version of a singly controlled operation.
    The modifier `C` indicates that the single-qubit operation is controllable., uid: Microsoft.Quantum.Canon.ApplyMultiControlledC}
- {summary: Applies a multiply controlled version of a singly controlled operation.
    The modifier `CA` indicates that the single-qubit operation is controllable and
    adjointable., uid: Microsoft.Quantum.Canon.ApplyMultiControlledCA}
- {summary: 'Implements a multiple-controlled Toffoli gate, assuming that target qubit
    is initialized 0.  The adjoint operation assumes that the target qubit will be
    reset to 0.', uid: Microsoft.Quantum.Canon.ApplyMultiplyControlledAnd}
- {summary: 'Implements a multiple-controlled Toffoli gate, assuming that target qubit
    is initialized 0.  The adjoint operation assumes that the target qubit will be
    reset to 0.  Requires a Rz depth of 1, while the number of helper qubits are exponential
    in the number of qubits.', uid: Microsoft.Quantum.Canon.ApplyMultiplyControlledLowDepthAnd}
- {summary: Applies the same op over a qubit register multiple times., uid: Microsoft.Quantum.Canon.ApplyOpRepeatedlyOver}
- {summary: Applies the same op over a qubit register multiple times., uid: Microsoft.Quantum.Canon.ApplyOpRepeatedlyOverA}
- {summary: Applies the same op over a qubit register multiple times., uid: Microsoft.Quantum.Canon.ApplyOpRepeatedlyOverC}
- {summary: Applies the same op over a qubit register multiple times., uid: Microsoft.Quantum.Canon.ApplyOpRepeatedlyOverCA}
- {summary: '', uid: Microsoft.Quantum.Canon.ApplyOperationRepeatedly}
- {summary: '', uid: Microsoft.Quantum.Canon.ApplyOperationRepeatedlyA}
- {summary: '', uid: Microsoft.Quantum.Canon.ApplyOperationRepeatedlyC}
- {summary: '', uid: Microsoft.Quantum.Canon.ApplyOperationRepeatedlyCA}
- {summary: 'Given a multi-qubit Pauli operator, applies the corresponding operation
    to a register.', uid: Microsoft.Quantum.Canon.ApplyPauli}
- {summary: Applies a Pauli operator on each qubit in an array if the corresponding
    bit of a Boolean array matches a given input., uid: Microsoft.Quantum.Canon.ApplyPauliFromBitString}
- {summary: Performs the Quantum Fourier Transform on a quantum register containing
    an integer in the little-endian representation., uid: Microsoft.Quantum.Canon.ApplyQuantumFourierTransform}
- {summary: Performs the Quantum Fourier Transform on a quantum register containing
    an integer in the big-endian representation., uid: Microsoft.Quantum.Canon.ApplyQuantumFourierTransformBE}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nApplyReversedOpBigEndianA has been deprecated.\
    \ Please use @\"microsoft.quantum.arithmetic.applyreversedopbea\" instead. Please\
    \ use @\"Microsoft.Quantum.Arithmetic.ApplyReversedOpBEA\".", uid: Microsoft.Quantum.Canon.ApplyReversedOpBigEndianA}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nApplyReversedOpBigEndianC has been deprecated.\
    \ Please use @\"microsoft.quantum.arithmetic.applyreversedopbec\" instead. Please\
    \ use @\"Microsoft.Quantum.Arithmetic.ApplyReversedOpBEC\".", uid: Microsoft.Quantum.Canon.ApplyReversedOpBigEndianC}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nApplyReversedOpBigEndianCA has been deprecated.\
    \ Please use @\"microsoft.quantum.arithmetic.applyreversedopbeca\" instead. Please\
    \ use @\"Microsoft.Quantum.Arithmetic.ApplyReversedOpBEC\".", uid: Microsoft.Quantum.Canon.ApplyReversedOpBigEndianCA}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nApplyReversedOpLittleEndianA has been\
    \ deprecated. Please use @\"microsoft.quantum.arithmetic.applyreversedoplea\"\
    \ instead. Please use @\"Microsoft.Quantum.Arithmetic.ApplyReversedOpLEA\".",
  uid: Microsoft.Quantum.Canon.ApplyReversedOpLittleEndianA}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nApplyReversedOpLittleEndianC has been\
    \ deprecated. Please use @\"microsoft.quantum.arithmetic.applyreversedoplec\"\
    \ instead. Please use @\"Microsoft.Quantum.Arithmetic.ApplyReversedOpLEC\".",
  uid: Microsoft.Quantum.Canon.ApplyReversedOpLittleEndianC}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nApplyReversedOpLittleEndianCA has been\
    \ deprecated. Please use @\"microsoft.quantum.arithmetic.applyreversedopleca\"\
    \ instead. Please use @\"Microsoft.Quantum.Arithmetic.ApplyReversedOpLEC\".",
  uid: Microsoft.Quantum.Canon.ApplyReversedOpLittleEndianCA}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nApplyRippleCarryComparatorLE has been\
    \ deprecated. Please use @\"microsoft.quantum.arithmetic.compareusingripplecarry\"\
    \ instead. Please use @\"Microsoft.Quantum.Arithmetic.CompareUsingRippleCarry\"\
    .", uid: Microsoft.Quantum.Canon.ApplyRippleCarryComparatorLE}
- {summary: Applies a list of ops and their targets sequentially on an array., uid: Microsoft.Quantum.Canon.ApplySeriesOfOps}
- {summary: Applies a list of ops and their targets sequentially on an array. (Adjoint),
  uid: Microsoft.Quantum.Canon.ApplySeriesOfOpsA}
- {summary: Applies a list of ops and their targets sequentially on an array. (Controlled),
  uid: Microsoft.Quantum.Canon.ApplySeriesOfOpsC}
- {summary: Applies a list of ops and their targets sequentially on an array. (Adjoint
    + Controlled), uid: Microsoft.Quantum.Canon.ApplySeriesOfOpsCA}
- {summary: Applies a single-qubit operation to each element in a register., uid: Microsoft.Quantum.Canon.ApplyToEach}
- {summary: Applies a single-qubit operation to each element in a register. The modifier
    `A` indicates that the single-qubit operation is adjointable., uid: Microsoft.Quantum.Canon.ApplyToEachA}
- {summary: Applies a single-qubit operation to each element in a register. The modifier
    `C` indicates that the single-qubit operation is controllable., uid: Microsoft.Quantum.Canon.ApplyToEachC}
- {summary: Applies a single-qubit operation to each element in a register. The modifier
    `CA` indicates that the single-qubit operation is controllable and adjointable.,
  uid: Microsoft.Quantum.Canon.ApplyToEachCA}
- {summary: Applies a single-qubit operation to each indexed element in a register.,
  uid: Microsoft.Quantum.Canon.ApplyToEachIndex}
- {summary: Applies a single-qubit operation to each indexed element in a register.
    The modifier `A` indicates that the single-qubit operation is adjointable., uid: Microsoft.Quantum.Canon.ApplyToEachIndexA}
- {summary: Applies a single-qubit operation to each indexed element in a register.
    The modifier `C` indicates that the single-qubit operation is controllable., uid: Microsoft.Quantum.Canon.ApplyToEachIndexC}
- {summary: Applies a single-qubit operation to each indexed element in a register.
    The modifier `CA` indicates that the single-qubit operation is adjointable and
    controllable., uid: Microsoft.Quantum.Canon.ApplyToEachIndexCA}
- {summary: Applies an operation to a given element of an array., uid: Microsoft.Quantum.Canon.ApplyToElement}
- {summary: Applies an operation to a given element of an array., uid: Microsoft.Quantum.Canon.ApplyToElementA}
- {summary: Applies an operation to a given element of an array., uid: Microsoft.Quantum.Canon.ApplyToElementC}
- {summary: Applies an operation to a given element of an array., uid: Microsoft.Quantum.Canon.ApplyToElementCA}
- {summary: Applies an operation to the first qubit in the register., uid: Microsoft.Quantum.Canon.ApplyToFirstQubit}
- {summary: Applies an operation to the first qubit in the register. The modifier
    `A` indicates that the operation is adjointable., uid: Microsoft.Quantum.Canon.ApplyToFirstQubitA}
- {summary: Applies operation op to the first qubit in the register. The modifier
    `C` indicates that the operation is controllable., uid: Microsoft.Quantum.Canon.ApplyToFirstQubitC}
- {summary: Applies operation op to the first qubit in the register. The modifier
    `CA` indicates that the operation is controllable and adjointable., uid: Microsoft.Quantum.Canon.ApplyToFirstQubitCA}
- {summary: Applies an operation to the first three qubits in the register., uid: Microsoft.Quantum.Canon.ApplyToFirstThreeQubits}
- {summary: Applies an operation to the first three qubits in the register. The modifier
    `A` indicates that the operation is adjointable., uid: Microsoft.Quantum.Canon.ApplyToFirstThreeQubitsA}
- {summary: Applies an operation to the first three qubits in the register. The modifier
    `C` indicates that the operation is controllable., uid: Microsoft.Quantum.Canon.ApplyToFirstThreeQubitsC}
- {summary: Applies an operation to the first three qubits in the register. The modifier
    `CA` indicates that the operation is controllable and adjointable., uid: Microsoft.Quantum.Canon.ApplyToFirstThreeQubitsCA}
- {summary: Applies an operation to the first two qubits in the register., uid: Microsoft.Quantum.Canon.ApplyToFirstTwoQubits}
- {summary: Applies an operation to the first two qubits in the register. The modifier
    `A` indicates that the operation is adjointable., uid: Microsoft.Quantum.Canon.ApplyToFirstTwoQubitsA}
- {summary: Applies an operation to the first two qubits in the register. The modifier
    `C` indicates that the operation is controllable., uid: Microsoft.Quantum.Canon.ApplyToFirstTwoQubitsC}
- {summary: Applies an operation to the first two qubits in the register. The modifier
    `CA` indicates that the operation is controllable and adjointable., uid: Microsoft.Quantum.Canon.ApplyToFirstTwoQubitsCA}
- {summary: Applies an operation to the first element of an array., uid: Microsoft.Quantum.Canon.ApplyToHead}
- {summary: Applies an operation to the first element of an array., uid: Microsoft.Quantum.Canon.ApplyToHeadA}
- {summary: Applies an operation to the first element of an array., uid: Microsoft.Quantum.Canon.ApplyToHeadC}
- {summary: Applies an operation to the first element of an array., uid: Microsoft.Quantum.Canon.ApplyToHeadCA}
- {summary: Applies an operation to all but the last element of an array., uid: Microsoft.Quantum.Canon.ApplyToMost}
- {summary: Applies an operation to all but the last element of an array., uid: Microsoft.Quantum.Canon.ApplyToMostA}
- {summary: Applies an operation to all but the last element of an array., uid: Microsoft.Quantum.Canon.ApplyToMostC}
- {summary: Applies an operation to all but the last element of an array., uid: Microsoft.Quantum.Canon.ApplyToMostCA}
- {summary: Applies a pair of operations to a given partition of a register into two
    parts., uid: Microsoft.Quantum.Canon.ApplyToPartition}
- {summary: Applies a pair of operations to a given partition of a register into two
    parts. The modifier `A` indicates that the operation is adjointable., uid: Microsoft.Quantum.Canon.ApplyToPartitionA}
- {summary: Applies a pair of operations to a given partition of a register into two
    parts. The modifier `C` indicates that the operation is controllable., uid: Microsoft.Quantum.Canon.ApplyToPartitionC}
- {summary: Applies a pair of operations to a given partition of a register into two
    parts. The modifier `CA` indicates that the operation is controllable and adjointable.,
  uid: Microsoft.Quantum.Canon.ApplyToPartitionCA}
- {summary: Applies an operation to all but the first element of an array., uid: Microsoft.Quantum.Canon.ApplyToRest}
- {summary: Applies an operation to all but the first element of an array., uid: Microsoft.Quantum.Canon.ApplyToRestA}
- {summary: Applies an operation to all but the first element of an array., uid: Microsoft.Quantum.Canon.ApplyToRestC}
- {summary: Applies an operation to all but the first element of an array., uid: Microsoft.Quantum.Canon.ApplyToRestCA}
- {summary: 'Applies an operation to a subregister of a register, with qubits specified
    by an array of their indices.', uid: Microsoft.Quantum.Canon.ApplyToSubregister}
- {summary: 'Applies an operation to a subregister of a register, with qubits specified
    by an array of their indices. The modifier `A` indicates that the operation is
    adjointable.', uid: Microsoft.Quantum.Canon.ApplyToSubregisterA}
- {summary: 'Applies an operation to a subregister of a register, with qubits specified
    by an array of their indices. The modifier `C` indicates that the operation is
    controllable.', uid: Microsoft.Quantum.Canon.ApplyToSubregisterC}
- {summary: 'Applies an operation to a subregister of a register, with qubits specified
    by an array of their indices. The modifier `CA` indicates that the operation is
    controllable and adjointable.', uid: Microsoft.Quantum.Canon.ApplyToSubregisterCA}
- {summary: Applies an operation to the last element of an array., uid: Microsoft.Quantum.Canon.ApplyToTail}
- {summary: Applies an operation to the last element of an array., uid: Microsoft.Quantum.Canon.ApplyToTailA}
- {summary: Applies an operation to the last element of an array., uid: Microsoft.Quantum.Canon.ApplyToTailC}
- {summary: Applies an operation to the last element of an array., uid: Microsoft.Quantum.Canon.ApplyToTailCA}
- {summary: 'Given two operations, applies one as conjugated with the other.', uid: Microsoft.Quantum.Canon.ApplyWith}
- {summary: 'Given two operations, applies one as conjugated with the other.', uid: Microsoft.Quantum.Canon.ApplyWithA}
- {summary: 'Given two operations, applies one as conjugated with the other.', uid: Microsoft.Quantum.Canon.ApplyWithC}
- {summary: 'Given two operations, applies one as conjugated with the other.', uid: Microsoft.Quantum.Canon.ApplyWithCA}
- {summary: 'Given an operation that accepts some input, a function that returns an
    output compatible with that operation, and an input to that function, applies
    the operation using the function to transform the input to a form expected by
    the operation.', uid: Microsoft.Quantum.Canon.ApplyWithInputTransformation}
- {summary: 'Given an operation that accepts some input, a function that returns an
    output compatible with that operation, and an input to that function, applies
    the operation using the function to transform the input to a form expected by
    the operation.', uid: Microsoft.Quantum.Canon.ApplyWithInputTransformationA}
- {summary: 'Given an operation that accepts some input, a function that returns an
    output compatible with that operation, and an input to that function, applies
    the operation using the function to transform the input to a form expected by
    the operation.', uid: Microsoft.Quantum.Canon.ApplyWithInputTransformationC}
- {summary: 'Given an operation that accepts some input, a function that returns an
    output compatible with that operation, and an input to that function, applies
    the operation using the function to transform the input to a form expected by
    the operation.', uid: Microsoft.Quantum.Canon.ApplyWithInputTransformationCA}
- {summary: Apply the Approximate Quantum Fourier Transform (AQFT) to a quantum register.,
  uid: Microsoft.Quantum.Canon.ApproximateQFT}
- {summary: 'Applies an array of complex phases to numeric basis states of a register
    of qubits, truncating small rotation angles according to a given tolerance.',
  uid: Microsoft.Quantum.Canon.ApproximatelyApplyDiagonalUnitary}
- {summary: 'Applies a Pauli rotation conditioned on an array of qubits, truncating
    small rotation angles according to a given tolerance.', uid: Microsoft.Quantum.Canon.ApproximatelyMultiplexPauli}
- {summary: 'Applies a Pauli Z rotation conditioned on an array of qubits, truncating
    small rotation angles according to a given tolerance.', uid: Microsoft.Quantum.Canon.ApproximatelyMultiplexZ}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAssertHighestBit has been deprecated.\
    \ Please use @\"microsoft.quantum.arithmetic.assertmostsignificantbit\" instead.\
    \ Please use @\"Microsoft.Quantum.Arithmetic.AssertMostSignificantBit\".", uid: Microsoft.Quantum.Canon.AssertHighestBit}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAssertLessThanPhaseLE has been deprecated.\
    \ Please use @\"microsoft.quantum.arithmetic.assertphaselessthan\" instead. Please\
    \ use @\"Microsoft.Quantum.Arithmetic.AssertPhaseLessThan\".", uid: Microsoft.Quantum.Canon.AssertLessThanPhaseLE}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAssertPhase has been deprecated. Please\
    \ use @\"microsoft.quantum.diagnostics.assertphase\" instead.", uid: Microsoft.Quantum.Canon.AssertPhase}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nCNOTChain has been deprecated. Please\
    \ use @\"microsoft.quantum.canon.applycnotchain\" instead.", uid: Microsoft.Quantum.Canon.CNOTChain}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nCNOTChainTarget has been deprecated.\
    \ Please use @\"microsoft.quantum.canon.applycnotchainwithtarget\" instead.",
  uid: Microsoft.Quantum.Canon.CNOTChainTarget}
- {summary: "Applies the controlled-X (CX) gate to a pair of qubits.\n$$ \\begin{align}\
    \ 1 & 0 & 0 & 0 \\\\\\\\ 0 & 1 & 0 & 0 \\\\\\\\ 0 & 0 & 0 & 1 \\\\\\\\ 0 & 0 &\
    \ 1 & 0 \\end{align}, $$ where rows and columns are organized as in the quantum\
    \ concepts guide.", uid: Microsoft.Quantum.Canon.CX}
- {summary: "Applies the controlled-Y (CY) gate to a pair of qubits.\n$$ \\begin{align}\
    \ 1 & 0 & 0 & 0 \\\\\\\\ 0 & 1 & 0 & 0 \\\\\\\\ 0 & 0 & 0 & -i \\\\\\\\ 0 & 0\
    \ & i & 0 \\end{align}, $$ where rows and columns are organized as in the quantum\
    \ concepts guide.", uid: Microsoft.Quantum.Canon.CY}
- {summary: "Applies the controlled-Z (CZ) gate to a pair of qubits.\n$$ \\begin{align}\
    \ 1 & 0 & 0 & 0 \\\\\\\\ 0 & 1 & 0 & 0 \\\\\\\\ 0 & 0 & 1 & 0 \\\\\\\\ 0 & 0 &\
    \ 0 & -1 \\end{align}, $$ where rows and columns are organized as in the quantum\
    \ concepts guide.", uid: Microsoft.Quantum.Canon.CZ}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nCascadeCCNOT has been deprecated. Please\
    \ use @\"microsoft.quantum.canon.applyccnotchain\" instead.", uid: Microsoft.Quantum.Canon.CascadeCCNOT}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nCascadeCNOT has been deprecated. Please\
    \ use @\"microsoft.quantum.canon.applycnotchain\" instead. Please use @\"microsoft.quantum.canon.applycnotchain\"\
    .", uid: Microsoft.Quantum.Canon.CascadeCNOT}
- {summary: Applies a given operation with a delay., uid: Microsoft.Quantum.Canon.Delay}
- {summary: Applies a given operation with a delay., uid: Microsoft.Quantum.Canon.DelayA}
- {summary: Applies a given operation with a delay., uid: Microsoft.Quantum.Canon.DelayC}
- {summary: Applies a given operation with a delay., uid: Microsoft.Quantum.Canon.DelayCA}
- {summary: "Applies the Y-basis analog to the Hadamard transformation that interchanges\
    \ the Z and Y axes.\nThe Y Hadamard transformation $H_Y = S H$ on a single qubit\
    \ is:\n\\begin{align} H_Y \\mathrel{:=} \\frac{1}{\\sqrt{2}} \\begin{bmatrix}\
    \ 1 & 1 \\\\\\\\ i & -i \\end{bmatrix}. \\end{align}", uid: Microsoft.Quantum.Canon.HY}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nInPlaceMajority has been deprecated.\
    \ Please use @\"microsoft.quantum.arithmetic.applymajorityinplace\" instead. Please\
    \ use @\"microsoft.quantum.arithmetic.applymajorityinplace\".", uid: Microsoft.Quantum.Canon.InPlaceMajority}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nInPlaceXorBE has been deprecated. Please\
    \ use @\"applyreversedopleca(applyxorinplace(value, _), target)\" instead. This\
    \ operation has been removed.", uid: Microsoft.Quantum.Canon.InPlaceXorBE}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nInPlaceXorLE has been deprecated. Please\
    \ use @\"microsoft.quantum.measurement.applyxorinplace\" instead. Please use @\"\
    Microsoft.Quantum.Measurement.ApplyXorInPlace\".", uid: Microsoft.Quantum.Canon.InPlaceXorLE}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nIntegerIncrementLE has been deprecated.\
    \ Please use @\"microsoft.quantum.arithmetic.incrementbyinteger\" instead. Please\
    \ use @\"Microsoft.Quantum.Arithmetic.IncrementByInteger\".", uid: Microsoft.Quantum.Canon.IntegerIncrementLE}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nIntegerIncrementPhaseLE has been deprecated.\
    \ Please use @\"microsoft.quantum.arithmetic.incrementphasebyinteger\" instead.\
    \ Please use @\"Microsoft.Quantum.Arithmetic.IncrementPhaseByInteger\".", uid: Microsoft.Quantum.Canon.IntegerIncrementPhaseLE}
- {summary: Applies an operation for each index in the Cartesian power of an integer
    range., uid: Microsoft.Quantum.Canon.IterateThroughCartesianPower}
- {summary: Applies an operation for each index in the Cartesian product of several
    ranges., uid: Microsoft.Quantum.Canon.IterateThroughCartesianProduct}
- {summary: Computes the logical AND of multiple qubits., uid: Microsoft.Quantum.Canon.LogicalANDMeasAndFix}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nModularAddProductLE has been deprecated.\
    \ Please use @\"microsoft.quantum.arithmetic.multiplyandaddbymodularinteger\"\
    \ instead. Please use @\"Microsoft.Quantum.Arithmetic.MultiplyAndAddByModularInteger\"\
    .", uid: Microsoft.Quantum.Canon.ModularAddProductLE}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nModularAddProductPhaseLE has been deprecated.\
    \ Please use @\"microsoft.quantum.arithmetic.multiplyandaddphasebymodularinteger\"\
    \ instead. Please use @\"Microsoft.Quantum.Arithmetic.MultiplyAndAddPhaseByModularInteger\"\
    .", uid: Microsoft.Quantum.Canon.ModularAddProductPhaseLE}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nModularIncrementLE has been deprecated.\
    \ Please use @\"microsoft.quantum.arithmetic.modularincrementbyinteger\" instead.\
    \ Please use @\"Microsoft.Quantum.Arithmetic.ModularIncrementByInteger\".", uid: Microsoft.Quantum.Canon.ModularIncrementLE}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nModularIncrementPhaseLE has been deprecated.\
    \ Please use @\"microsoft.quantum.arithmetic.incrementphasebymodularinteger\"\
    \ instead. Please use @\"Microsoft.Quantum.Arithmetic.IncrementPhaseByModularInteger\"\
    .", uid: Microsoft.Quantum.Canon.ModularIncrementPhaseLE}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nModularMultiplyByConstantLE has been\
    \ deprecated. Please use @\"microsoft.quantum.arithmetic.multiplybymodularinteger\"\
    \ instead. Please use @\"Microsoft.Quantum.Arithmetic.MultiplyByModularInteger\"\
    .", uid: Microsoft.Quantum.Canon.ModularMultiplyByConstantLE}
- {summary: "Applies an array of operations controlled by an array of number states.\n\
    That is, applies Multiply-controlled unitary operation $U$ that applies a unitary\
    \ $V_j$ when controlled by $n$-qubit number state $\\ket{j}$.\n$U = \\sum^{2^n-1}_{j=0}\\\
    ket{j}\\bra{j}\\otimes V_j$.", uid: Microsoft.Quantum.Canon.MultiplexOperations}
- {summary: "Applies multiply-controlled unitary operation $U$ that applies a unitary\
    \ $V_j$ when controlled by n-qubit number state $\\ket{j}$.\n$U = \\sum^{N-1}_{j=0}\\\
    ket{j}\\bra{j}\\otimes V_j$.", uid: Microsoft.Quantum.Canon.MultiplexOperationsBruteForceFromGenerator}
- {summary: "Applies a multiply-controlled unitary operation $U$ that applies a unitary\
    \ $V_j$ when controlled by n-qubit number state $\\ket{j}$.\n$U = \\sum^{N-1}_{j=0}\\\
    ket{j}\\bra{j}\\otimes V_j$.", uid: Microsoft.Quantum.Canon.MultiplexOperationsFromGenerator}
- {summary: Implementation step of MultiplexOperations., uid: Microsoft.Quantum.Canon.MultiplexOperationsWithAuxRegister}
- {summary: Applies a Pauli rotation conditioned on an array of qubits., uid: Microsoft.Quantum.Canon.MultiplexPauli}
- {summary: Applies a Pauli Z rotation conditioned on an array of qubits., uid: Microsoft.Quantum.Canon.MultiplexZ}
- {summary: Performs the identity operation (no-op) on an argument., uid: Microsoft.Quantum.Canon.NoOp}
- {summary: Permutes qubits by using the SWAP operation., uid: Microsoft.Quantum.Canon.PermuteQubits}
- {summary: Performs the Quantum Fourier Transform on a quantum register containing
    an integer in the big-endian representation., uid: Microsoft.Quantum.Canon.QFT}
- {summary: Performs the Quantum Fourier Transform on a quantum register containing
    an integer in the little-endian representation., uid: Microsoft.Quantum.Canon.QFTLE}
- {summary: "Performs a phase shift operation.\n$R=\\boldone-(1-e^{i \\phi})\\ket{0\\\
    cdots 0}\\bra{0\\cdots 0}$.", uid: Microsoft.Quantum.Canon.RAll0}
- {summary: "Performs a phase shift operation.\n$R=\\boldone-(1-e^{i \\phi})\\ket{1\\\
    cdots 1}\\bra{1\\cdots 1}$.", uid: Microsoft.Quantum.Canon.RAll1}
- {summary: Repeats an operation a given number of times., uid: Microsoft.Quantum.Canon.Repeat}
- {summary: Repeats an operation a given number of times., uid: Microsoft.Quantum.Canon.RepeatA}
- {summary: Repeats an operation a given number of times., uid: Microsoft.Quantum.Canon.RepeatC}
- {summary: Repeats an operation a given number of times., uid: Microsoft.Quantum.Canon.RepeatCA}
- {summary: Uses SWAP gates to Reversed the order of the qubits in a register., uid: Microsoft.Quantum.Canon.SwapReverseRegister}
- {summary: "Implementation of the first-order Trotter\u2013Suzuki integrator.", uid: Microsoft.Quantum.Canon.Trotter1ImplCA}
- {summary: "Implementation of the second-order Trotter\u2013Suzuki integrator.",
  uid: Microsoft.Quantum.Canon.Trotter2ImplCA}
- {summary: "Recursive implementation of even-order Trotter\u2013Suzuki integrator.",
  uid: Microsoft.Quantum.Canon.TrotterArbitraryImplCA}
- {summary: Implementation step of `MultiplexOperationsFromGenerator`., uid: Microsoft.Quantum.Canon._MultiplexOperationsFromGenerator}
- {summary: '', uid: Microsoft.Quantum.Characterization.ApplyHadamardTest}
- {summary: '', uid: Microsoft.Quantum.Characterization.ApplyHadamardTestOnSingleRegister}
- {summary: '', uid: Microsoft.Quantum.Characterization.ApplySwapTest}
- {summary: '', uid: Microsoft.Quantum.Characterization.ApplySwapTestOnSingleRegister}
- {summary: Performs a single iteration of an iterative (classically-controlled) phase
    estimation algorithm using arbitrary real powers of a unitary oracle., uid: Microsoft.Quantum.Characterization.ContinuousPhaseEstimationIteration}
- {summary: Performs a single iteration of an iterative (classically-controlled) phase
    estimation algorithm using integer powers of a unitary oracle., uid: Microsoft.Quantum.Characterization.DiscretePhaseEstimationIteration}
- {summary: 'Given a preparation and measurement, estimates the frequency with which
    that measurement succeeds (returns `Zero`) by performing a given number of trials.',
  uid: Microsoft.Quantum.Characterization.EstimateFrequency}
- {summary: 'Given a preparation that is adjointable and measurement, estimates the
    frequency with which that measurement succeeds (returns `Zero`) by performing
    a given number of trials.', uid: Microsoft.Quantum.Characterization.EstimateFrequencyA}
- {summary: 'Given two operations which each prepare copies of a state, estimates
    the imaginary part of the overlap between the states prepared by each operation.',
  uid: Microsoft.Quantum.Characterization.EstimateImagOverlapBetweenStates}
- {summary: 'Given two operations which each prepare copies of a state, estimates
    the squared overlap between the states prepared by each operation.', uid: Microsoft.Quantum.Characterization.EstimateOverlapBetweenStates}
- {summary: 'Given two operations which each prepare copies of a state, estimates
    the real part of the overlap between the states prepared by each operation.',
  uid: Microsoft.Quantum.Characterization.EstimateRealOverlapBetweenStates}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nMeasureAllZ has been deprecated. Please\
    \ use @\"microsoft.quantum.measurement.measureallz\" instead. Please use @\"microsoft.quantum.measurement.measureAllZ\"\
    .", uid: Microsoft.Quantum.Characterization.MeasureAllZ}
- {summary: Measures the identity operator on a register of qubits., uid: Microsoft.Quantum.Characterization.MeasureIdentity}
- {summary: 'Performs the quantum phase estimation algorithm for a given oracle `U`
    and `targetState`, reading the phase into a big-endian quantum register.', uid: Microsoft.Quantum.Characterization.QuantumPhaseEstimation}
- {summary: 'Performs the robust non-iterative quantum phase estimation algorithm
    for a given oracle `U` and eigenstate, and provides a single real-valued estimate
    of the phase with variance scaling at the Heisenberg limit.', uid: Microsoft.Quantum.Characterization.RobustPhaseEstimation}
- {summary: 'Performs a single-qubit process tomography measurement in the Pauli basis,
    given a particular channel of interest.', uid: Microsoft.Quantum.Characterization.SingleQubitProcessTomographyMeasurement}
- {summary: "Represents a dynamical generator as a set of simulatable gates and an\
    \ expansion in the JordanWigner basis.\nSee [Dynamical Generator Modeling](../libraries/data-structures#dynamical-generator-modeling)\
    \ for more details.", uid: Microsoft.Quantum.Chemistry.JordanWigner.JordanWignerFermionImpl}
- {summary: 'A unitary $U$ that applies the Pauli string on $(X^{z+1}\_pY^{z}\_p)Z\_{p-1}...Z_0$
    on qubits $0..p$ conditioned on an index $z\in\{0,1\}$ and $p$. That is, $$ \begin{align}
    U\ket{z}\ket{p}\ket{\psi} = \ket{z}\ket{p}(X^{z+1}\_pY^{z}\_p)Z\_{p-1}...Z_0\ket{\psi}
    \end{align} $$', uid: Microsoft.Quantum.Chemistry.JordanWigner.OptimizedBEXY}
- {summary: Simple state preparation of trial state by occupying spin-orbitals, uid: Microsoft.Quantum.Chemistry.JordanWigner.PrepareSingleConfigurationalStateSingleSiteOccupation}
- {summary: Sparse multi-configurational state preparation of trial state by adding
    excitations to initial trial state., uid: Microsoft.Quantum.Chemistry.JordanWigner.PrepareSparseMultiConfigurationalState}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner.PrepareTrialState}
- {summary: Unitary coupled-cluster state preparation of trial state, uid: Microsoft.Quantum.Chemistry.JordanWigner.PrepareUnitaryCoupledClusterState}
- {summary: 'A unitary $U$ that applies the Pauli $Z$ gate on a qubits $p$ conditioned
    on an index state $\ket{p}$. That is, $$ \begin{align} U\ket{p}\ket{\psi} = \ket{p}Z\_p\ket{\psi}
    \end{align} $$', uid: Microsoft.Quantum.Chemistry.JordanWigner.SelectZ}
- {summary: Estimates the energy of the molecule by summing the energy contributed
    by the individual Jordan-Wigner terms., uid: Microsoft.Quantum.Chemistry.JordanWigner.VQE.EstimateEnergy}
- {summary: Computes the energy associated to a given Jordan-Wigner Hamiltonian term,
  uid: Microsoft.Quantum.Chemistry.JordanWigner.VQE.EstimateTermExpectation}
- {summary: 'Private wrapper around PrepareTrialState to make it compatible with EstimateFrequencyA
    by defining an adjoint. EstimateFrequencyA has built-in emulation feature when
    targeting the QuantumSimulator, which speeds up its execution.', uid: Microsoft.Quantum.Chemistry.JordanWigner.VQE._prepareTrialStateWrapper}
- {summary: Applies time-evolution by a PQRS term described by a `GeneratorIndex`.,
  uid: Microsoft.Quantum.Chemistry.JordanWigner._ApplyJordanWigner0123Term_}
- {summary: Applies time-evolution by a cluster operator PQRS term described by a
    `GeneratorIndex`., uid: Microsoft.Quantum.Chemistry.JordanWigner._ApplyJordanWignerClusterOperatorPQRSTerm}
- {summary: Applies time-evolution by a cluster operator PQ term described by a `GeneratorIndex`.,
  uid: Microsoft.Quantum.Chemistry.JordanWigner._ApplyJordanWignerClusterOperatorPQTerm}
- {summary: Applies time-evolution by a PQ term described by a `GeneratorIndex`.,
  uid: Microsoft.Quantum.Chemistry.JordanWigner._ApplyJordanWignerPQTerm_}
- {summary: Applies time-evolution by a PQ or PQQR term described by a `GeneratorIndex`.,
  uid: Microsoft.Quantum.Chemistry.JordanWigner._ApplyJordanWignerPQandPQQRTerm_}
- {summary: Applies time-evolution by a Z term described by a `GeneratorIndex`., uid: Microsoft.Quantum.Chemistry.JordanWigner._ApplyJordanWignerZTerm_}
- {summary: Applies time-evolution by a ZZ term described by a `GeneratorIndex`.,
  uid: Microsoft.Quantum.Chemistry.JordanWigner._ApplyJordanWignerZZTerm_}
- {summary: "Represents a dynamical generator as a set of simulatable gates and an\
    \ expansion in the JordanWigner basis.\nSee [Dynamical Generator Modeling](../libraries/data-structures#dynamical-generator-modeling)\
    \ for more details.", uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerClusterOperatorImpl}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerOptimizedBlockEncodingSelect_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerOptimizedBlockEncodingStatePrep}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerOptimizedBlockEncodingStatePrep_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._JordanWignerSelect_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._MergeTwoRegisters_}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._OptimizedBEXY}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._SelectZ}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._ToJordanWignerSelectInput}
- {summary: '', uid: Microsoft.Quantum.Chemistry.JordanWigner._ToPauliBases}
- {summary: Calls a function with a given input., uid: Microsoft.Quantum.Convert.Call}
- {summary: 'Between a call to this operation and its adjoint, asserts that a given
    operation is called at most a certain number of times.', uid: Microsoft.Quantum.Diagnostics.AllowAtMostNCallsCA}
- {summary: 'Between a call to this operation and its adjoint, asserts that at most
    a given number of additional qubits are allocated with using statements.', uid: Microsoft.Quantum.Diagnostics.AllowAtMostNQubits}
- {summary: 'Assert that given qubits are all in $\ket{0}$ state.', uid: Microsoft.Quantum.Diagnostics.AssertAllZero}
- {summary: 'Assert that given qubits are all in $\ket{0}$ state up to a given tolerance.',
  uid: Microsoft.Quantum.Diagnostics.AssertAllZeroWithinTolerance}
- {summary: Asserts that measuring the given qubits in the given Pauli basis will
    always have the given result., uid: Microsoft.Quantum.Diagnostics.AssertMeasurement}
- {summary: 'Asserts that measuring the given qubits in the given Pauli basis will
    have the given result with the given probability, within some tolerance.', uid: Microsoft.Quantum.Diagnostics.AssertMeasurementProbability}
- {summary: "Given two operations, asserts that they act identically for all input\
    \ states.\nThis assertion is implemented by checking the action of the operations\
    \ on all states of the form $V_0 \\otimes ... \\otimes V_{n-1}$, where $V_k$ is\
    \ one of the states $\\ket{0}$, $\\ket{1}$, $\\ket{+}$ and $\\ket{i}$ (+1 eigenstate\
    \ of Pauli Y operator).\nThis assertion uses $n$ qubits and requires multiple\
    \ calls of the operations being compared.", uid: Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlace}
- {summary: 'Checks if the operation `givenU` is equal to the operation `expectedU`
    on the given input size  by checking the action of the operations only on the
    vectors from the computational basis. This is a necessary, but not sufficient,
    condition for the equality of two unitaries.', uid: Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlaceCompBasis}
- {summary: "Given two operations, asserts that they act identically for all input\
    \ states.\nThis assertion is implemented by using the Choi\u2013Jami\u0142kowski\
    \ isomorphism to reduce the assertion to one of a qubit state assertion on two\
    \ entangled registers. Thus, this operation needs only a single call to each operation\
    \ being tested, but requires twice as many qubits to be allocated. This assertion\
    \ can be used to ensure, for instance, that an optimized version of an operation\
    \ acts identically to its na\xEFve implementation, or that an operation which\
    \ acts on a range of non-quantum inputs agrees with known cases.", uid: Microsoft.Quantum.Diagnostics.AssertOperationsEqualReferenced}
- {summary: Asserts that the phase of an equal superposition state has the expected
    value., uid: Microsoft.Quantum.Diagnostics.AssertPhase}
- {summary: Asserts that the qubit `q` is in the expected eigenstate of the Pauli
    Z operator., uid: Microsoft.Quantum.Diagnostics.AssertQubit}
- {summary: "Asserts that a qubit in the expected state.\n`expected` represents a\
    \ complex vector, $\\ket{\\psi} = \\begin{bmatrix}a & b\\end{bmatrix}^{\\mathrm{T}}$.\
    \ The first element of the tuples representing each of $a$, $b$ is the real part\
    \ of the complex number, while the second one is the imaginary part. The last\
    \ argument defines the tolerance with which assertion is made.", uid: Microsoft.Quantum.Diagnostics.AssertQubitIsInStateWithinTolerance}
- {summary: Asserts that the qubit `q` is in the expected eigenstate of the Pauli
    Z operator up to a given tolerance., uid: Microsoft.Quantum.Diagnostics.AssertQubitWithinTolerance}
- {summary: 'Given an operation, displays diagnostics about the operation that are
    made available by the current execution target.', uid: Microsoft.Quantum.Diagnostics.DumpOperation}
- {summary: 'Uses DumpRegister to provide diagnostics on the state of a reference
    and target register. Written as separate operation to allow overriding and interpreting
    as separate registers, rather than as a single combined register.', uid: Microsoft.Quantum.Diagnostics.DumpReferenceAndTarget}
- {summary: Checks if the result of applying two operations `givenU` and `expectedU`
    to a basis state is the same. The basis state is described by `basis` parameter.
    See <xref:microsoft.quantum.extensions.fliptobasis> function for more details
    on this description., uid: Microsoft.Quantum.Diagnostics._assertEqualOnBasisVector}
- {summary: "Applies unitaries that map $\\ket{0}\\otimes\\cdots\\ket{0}$ to $\\ket{\\\
    psi_0} \\otimes \\ket{\\psi_{n - 1}}$, where $\\ket{\\psi_k}$ depends on `basis[k]`.\n\
    The correspondence between value of `basis[k]` and $\\ket{\\psi_k}$ is the following:\n\
    - `basis[k]=0` $\\rightarrow \\ket{0}$. - `basis[k]=1` $\\rightarrow \\ket{1}$.\
    \ - `basis[k]=2` $\\rightarrow \\ket{+}$. - `basis[k]=3` $\\rightarrow \\ket{i}$\
    \ ( +1 eigenstate of Pauli Y ).", uid: Microsoft.Quantum.Diagnostics._flipToBasis}
- {summary: "Iterates a variable through a Cartesian product [ 0, bounds[0]-1 ] \xD7\
    \ [ 0, bounds[1]-1 ] \xD7 [ 0, bounds[Length(bounds)-1]-1 ] and calls op(arr)\
    \ for every element of the Cartesian product", uid: Microsoft.Quantum.Diagnostics._iterateThroughCartesianPower}
- {summary: "Given two registers, prepares the maximally entangled state between each\
    \ pair of qubits on the respective registers. All qubits must start in the |0\u27E9\
    \ state.\nThe result is that corresponding pairs of qubits from each register\
    \ are in the $\\bra{\\beta_{00}}\\ket{\\beta_{00}}$.", uid: Microsoft.Quantum.Diagnostics._prepareEntangledState}
- {summary: 'Returns the number of qubits currently available to borrow. This includes
    unused qubits; that is, this includes the qubits returned by `GetQubitsAvailableToUse`.',
  uid: Microsoft.Quantum.Environment.GetQubitsAvailableToBorrow}
- {summary: Returns the number of qubits currently available to use., uid: Microsoft.Quantum.Environment.GetQubitsAvailableToUse}
- {summary: "Private operation used to implement both the bit flip encoder and decoder.\n\
    Note that this encoder can make use of in-place coherent recovery, in which case\
    \ it will \"cause\" the error described by the initial state of `auxQubits`. In\
    \ particular, if `auxQubits` are initially in the state $\\ket{10}$, this will\
    \ cause an $X_1$ error on the encoded qubit.", uid: Microsoft.Quantum.ErrorCorrection.ApplyBitFlipEncoder}
- {summary: "Decodes from the [3, 1, 3] / \u27E63, 1, 1\u27E7 bit-flip code.", uid: Microsoft.Quantum.ErrorCorrection.DecodeFromBitFlipCode}
- {summary: "Decodes the \u27E65, 1, 3\u27E7 quantum code.", uid: Microsoft.Quantum.ErrorCorrection.DecodeFromFiveQubitCode}
- {summary: "An inverse encoding operation that maps an unencoded quantum register\
    \ to an encoded quantum register under the \u27E67, 1, 3\u27E7 Steane quantum\
    \ code.", uid: Microsoft.Quantum.ErrorCorrection.DecodeFromSteaneCode}
- {summary: "Encodes into the [3, 1, 3] / \u27E63, 1, 1\u27E7 bit-flip code.", uid: Microsoft.Quantum.ErrorCorrection.EncodeIntoBitFlipCode}
- {summary: "Encodes into the \u27E65, 1, 3\u27E7 quantum code.", uid: Microsoft.Quantum.ErrorCorrection.EncodeIntoFiveQubitCode}
- {summary: "An encoding operation that maps an unencoded quantum register to an encoded\
    \ quantum register under the \u27E67, 1, 3\u27E7 Steane quantum code.", uid: Microsoft.Quantum.ErrorCorrection.EncodeIntoSteaneCode}
- {summary: Private operation used to implement both the 5 qubit encoder and decoder.,
  uid: Microsoft.Quantum.ErrorCorrection.FiveQubitCodeEncoderImpl}
- {summary: "Rotates a single qubit by \u03C0/4 about the Y-axis.", uid: Microsoft.Quantum.ErrorCorrection.InjectPi4YRotation}
- {summary: Implements the Knill magic state distillation algorithm., uid: Microsoft.Quantum.ErrorCorrection.KnillDistill}
- {summary: Measures the given set of generators of a stabilizer group., uid: Microsoft.Quantum.ErrorCorrection.MeasureStabilizerGenerators}
- {summary: Performs a single round of error correction by a quantum code described
    by a `QECC` type., uid: Microsoft.Quantum.ErrorCorrection.Recover}
- {summary: Performs a single round of error correction by a quantum code described
    by a `CSS` type., uid: Microsoft.Quantum.ErrorCorrection.RecoverCSS}
- {summary: Private operation used to implement both the Steane code encoder and decoder.,
  uid: Microsoft.Quantum.ErrorCorrection.SteaneCodeEncoderImpl}
- {summary: "Syndrome measurement and the inverse of embedding.\n$X$- and $Z$-stabilizers\
    \ are not treated equally, which is due to the particular choice of the encoding\
    \ circuit. This asymmetry leads to a different syndrome extraction routine. One\
    \ could measure the syndrome by measuring multi-qubit Pauli operator directly\
    \ on the code state, but for the distillation purpose the logical qubit is returned\
    \ into a single qubit, in course of which the syndrome measurements can be done\
    \ without further ancillas.", uid: Microsoft.Quantum.ErrorCorrection._ExtractLogicalQubitFromSteaneCode}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAssertAllZero has been deprecated. Please\
    \ use @\"microsoft.quantum.diagnostics.assertallzero\" instead. Please use @\"\
    microsoft.quantum.diagnostics.assertallzero\".", uid: Microsoft.Quantum.Extensions.Testing.AssertAllZero}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAssertAllZeroTol has been deprecated.\
    \ Please use @\"microsoft.quantum.diagnostics.assertallzerowithintolerance\" instead.\
    \ Please use @\"microsoft.quantum.diagnostics.assertallzerowithintolerance\".",
  uid: Microsoft.Quantum.Extensions.Testing.AssertAllZeroTol}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAssertOperationsEqualInPlace has been\
    \ deprecated. Please use @\"microsoft.quantum.diagnostics.assertoperationsequalinplace\"\
    \ instead. Please use @\"microsoft.quantum.diagnostics.assertoperationsequalinplace\"\
    . Note that the order of the arguments to this operation has changed.", uid: Microsoft.Quantum.Extensions.Testing.AssertOperationsEqualInPlace}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAssertOperationsEqualInPlaceCompBasis\
    \ has been deprecated. Please use @\"microsoft.quantum.diagnostics.assertoperationsequalinplacecompbasis\"\
    \ instead. Please use @\"microsoft.quantum.diagnostics.assertoperationsequalinplaceCompBasis\"\
    . Note that the order of the arguments to this operation has changed.", uid: Microsoft.Quantum.Extensions.Testing.AssertOperationsEqualInPlaceCompBasis}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAssertOperationsEqualReferenced has been\
    \ deprecated. Please use @\"microsoft.quantum.diagnostics.assertoperationsequalreferenced\"\
    \ instead. Please use @\"microsoft.quantum.diagnostics.assertoperationsequalreferenced\"\
    . Note that the order of the arguments to this operation has changed.", uid: Microsoft.Quantum.Extensions.Testing.AssertOperationsEqualReferenced}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAssertQubit has been deprecated. Please\
    \ use @\"microsoft.quantum.diagnostics.assertqubit\" instead. Please use @\"microsoft.quantum.diagnostics.assertqubit\"\
    .", uid: Microsoft.Quantum.Extensions.Testing.AssertQubit}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAssertQubitState has been deprecated.\
    \ Please use @\"microsoft.quantum.diagnostics.assertqubitisinstatewithintolerance\"\
    \ instead. Please use @\"microsoft.quantum.diagnostics.assertqubitisinstatewithintolerance\"\
    .", uid: Microsoft.Quantum.Extensions.Testing.AssertQubitState}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAssertQubitTol has been deprecated. Please\
    \ use @\"microsoft.quantum.diagnostics.assertqubitwithintolerance\" instead. Please\
    \ use @\"microsoft.quantum.diagnostics.assertqubitwithintolerance\".", uid: Microsoft.Quantum.Extensions.Testing.AssertQubitTol}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAssert has been deprecated. Please use\
    \ @\"microsoft.quantum.diagnostics.assertmeasurement\" instead.", uid: Microsoft.Quantum.Intrinsic.Assert}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nAssertProb has been deprecated. Please\
    \ use @\"microsoft.quantum.diagnostics.assertmeasurementprobability\" instead.",
  uid: Microsoft.Quantum.Intrinsic.AssertProb}
- {summary: "Applies the doubly controlled\u2013NOT (CCNOT) gate to three qubits.",
  uid: Microsoft.Quantum.Intrinsic.CCNOT}
- {summary: "Applies the controlled-NOT (CNOT) gate to a pair of qubits.\n\\begin{align}\
    \ \\operatorname{CNOT} \\mathrel{:=} \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\\\\\ 0\
    \ & 1 & 0 & 0 \\\\\\\\ 0 & 0 & 0 & 1 \\\\\\\\ 0 & 0 & 1 & 0 \\end{bmatrix}, \\\
    end{align}\nwhere rows and columns are ordered as in the quantum concepts guide.",
  uid: Microsoft.Quantum.Intrinsic.CNOT}
- {summary: "Applies the exponential of a multi-qubit Pauli operator.\n\\begin{align}\
    \ e^{i \\theta [P_0 \\otimes P_1 \\cdots P_{N-1}]}, \\end{align} where $P_i$ is\
    \ the $i$th element of `paulis`, and where $N = $`Length(paulis)`.", uid: Microsoft.Quantum.Intrinsic.Exp}
- {summary: "Applies the exponential of a multi-qubit Pauli operator with an argument\
    \ given by a dyadic fraction.\n\\begin{align} e^{i \\pi k [P_0 \\otimes P_1 \\\
    cdots P_{N-1}] / 2^n}, \\end{align} where $P_i$ is the $i$th element of `paulis`,\
    \ and where $N = $`Length(paulis)`.", uid: Microsoft.Quantum.Intrinsic.ExpFrac}
- {summary: "Applies the Hadamard transformation to a single qubit.\n\\begin{align}\
    \ H \\mathrel{:=} \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 & 1 \\\\\\\\ 1 & -1\
    \ \\end{bmatrix}. \\end{align}", uid: Microsoft.Quantum.Intrinsic.H}
- {summary: Performs the identity operation (no-op) on a single qubit., uid: Microsoft.Quantum.Intrinsic.I}
- {summary: "Performs a measurement of a single qubit in the Pauli $Z$ basis.\nThe\
    \ output result is given by the distribution \\begin{align} \\Pr(\\texttt{Zero}\
    \ | \\ket{\\psi}) = \\braket{\\psi | 0} \\braket{0 | \\psi}. \\end{align}", uid: Microsoft.Quantum.Intrinsic.M}
- {summary: "Performs a joint measurement of one or more qubits in the specified Pauli\
    \ bases.\nThe output result is given by the distribution: \\begin{align} \\Pr(\\\
    texttt{Zero} | \\ket{\\psi}) = \\frac12 \\braket{ \\psi \\mid| \\left( \\boldone\
    \ + P_0 \\otimes P_1 \\otimes \\cdots \\otimes P_{N-1} \\right) \\mid| \\psi },\
    \ \\end{align} where $P_i$ is the $i$th element of `bases`, and where $N = \\\
    texttt{Length}(\\texttt{bases})$. That is, measurement returns a `Result` $d$\
    \ such that the eigenvalue of the observed measurement effect is $(-1)^d$.", uid: Microsoft.Quantum.Intrinsic.Measure}
- {summary: "Applies a rotation about the given Pauli axis.\n\\begin{align} R_{\\\
    mu}(\\theta) \\mathrel{:=} e^{-i \\theta \\sigma_{\\mu} / 2}, \\end{align} where\
    \ $\\mu \\in \\{I, X, Y, Z\\}$.", uid: Microsoft.Quantum.Intrinsic.R}
- {summary: "Applies a rotation about the $\\ket{1}$ state by a given angle.\n\\begin{align}\
    \ R_1(\\theta) \\mathrel{:=} \\operatorname{diag}(1, e^{i\\theta}). \\end{align}",
  uid: Microsoft.Quantum.Intrinsic.R1}
- {summary: "Applies a rotation about the $\\ket{1}$ state by an angle specified as\
    \ a dyadic fraction.\n\\begin{align} R_1(n, k) \\mathrel{:=} \\operatorname{diag}(1,\
    \ e^{i \\pi k / 2^n}). \\end{align}\n> [!WARNING] > This operation uses the **opposite**\
    \ sign convention from > @\"microsoft.quantum.intrinsic.r\", and does not include\
    \ the > factor of $1/ 2$ included by @\"microsoft.quantum.intrinsic.r1\".", uid: Microsoft.Quantum.Intrinsic.R1Frac}
- {summary: "Applies a rotation about the given Pauli axis by an angle specified as\
    \ a dyadic fraction.\n\\begin{align} R_{\\mu}(n, k) \\mathrel{:=} e^{i \\pi n\
    \ \\sigma_{\\mu} / 2^k}, \\end{align} where $\\mu \\in \\{I, X, Y, Z\\}$.\n> [!WARNING]\
    \ > This operation uses the **opposite** sign convention from > @\"microsoft.quantum.intrinsic.r\"\
    .", uid: Microsoft.Quantum.Intrinsic.RFrac}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nRandom has been deprecated. Please use\
    \ @\"microsoft.quantum.random.drawcategorical\" instead.", uid: Microsoft.Quantum.Intrinsic.Random}
- {summary: "Given a single qubit, measures it and ensures it is in the |0\u27E9 state\
    \ such that it can be safely released.", uid: Microsoft.Quantum.Intrinsic.Reset}
- {summary: "Given an array of qubits, measure them and ensure they are in the |0\u27E9\
    \ state such that they can be safely released.", uid: Microsoft.Quantum.Intrinsic.ResetAll}
- {summary: "Applies a rotation about the $x$-axis by a given angle.\n\\begin{align}\
    \ R_x(\\theta) \\mathrel{:=} e^{-i \\theta \\sigma_x / 2} = \\begin{bmatrix} \\\
    cos \\frac{\\theta}{2} & -i\\sin \\frac{\\theta}{2}  \\\\\\\\ -i\\sin \\frac{\\\
    theta}{2} & \\cos \\frac{\\theta}{2} \\end{bmatrix}. \\end{align}", uid: Microsoft.Quantum.Intrinsic.Rx}
- {summary: "Applies a rotation about the $y$-axis by a given angle.\n\\begin{align}\
    \ R_y(\\theta) \\mathrel{:=} e^{-i \\theta \\sigma_y / 2} = \\begin{bmatrix} \\\
    cos \\frac{\\theta}{2} & -\\sin \\frac{\\theta}{2}  \\\\\\\\ \\sin \\frac{\\theta}{2}\
    \ & \\cos \\frac{\\theta}{2} \\end{bmatrix}. \\end{align}", uid: Microsoft.Quantum.Intrinsic.Ry}
- {summary: "Applies a rotation about the $z$-axis by a given angle.\n\\begin{align}\
    \ R_z(\\theta) \\mathrel{:=} e^{-i \\theta \\sigma_z / 2} = \\begin{bmatrix} e^{-i\
    \ \\theta / 2} & 0 \\\\\\\\ 0 & e^{i \\theta / 2} \\end{bmatrix}. \\end{align}",
  uid: Microsoft.Quantum.Intrinsic.Rz}
- {summary: Applies the S gate to a single qubit., uid: Microsoft.Quantum.Intrinsic.S}
- {summary: "Applies the SWAP gate to a pair of qubits.\n\\begin{align} \\operatorname{SWAP}\
    \ \\mathrel{:=} \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\\\\\ 0 & 0 & 1 & 0 \\\\\\\\\
    \ 0 & 1 & 0 & 0 \\\\\\\\ 0 & 0 & 0 & 1 \\end{bmatrix}, \\end{align}\nwhere rows\
    \ and columns are ordered as in the quantum concepts guide.", uid: Microsoft.Quantum.Intrinsic.SWAP}
- {summary: Applies the T gate to a single qubit., uid: Microsoft.Quantum.Intrinsic.T}
- {summary: "Applies the Pauli $X$ gate.\n\\begin{align} \\sigma_x \\mathrel{:=} \\\
    begin{bmatrix} 0 & 1 \\\\\\\\ 1 & 0 \\end{bmatrix}. \\end{align}", uid: Microsoft.Quantum.Intrinsic.X}
- {summary: "Applies the Pauli $Y$ gate.\n\\begin{align} \\sigma_y \\mathrel{:=} \\\
    begin{bmatrix} 0 & -i \\\\\\\\ i & 0 \\end{bmatrix}. \\end{align}", uid: Microsoft.Quantum.Intrinsic.Y}
- {summary: "Applies the Pauli $Z$ gate.\n\\begin{align} \\sigma_z \\mathrel{:=} \\\
    begin{bmatrix} 1 & 0 \\\\\\\\ 0 & -1 \\end{bmatrix}. \\end{align}", uid: Microsoft.Quantum.Intrinsic.Z}
- {summary: 'Given the structure and parameterization of a sequential classifier,
    applies the classifier to a register of qubits.', uid: Microsoft.Quantum.MachineLearning.ApplySequentialClassifier}
- {summary: '', uid: Microsoft.Quantum.MachineLearning.Datasets.IrisTrainingData}
- {summary: '', uid: Microsoft.Quantum.MachineLearning.Datasets.WineData}
- {summary: 'Given a set of samples and a sequential classifier, estimates the classification
    probability for those samples by repeatedly measuring the output of the classifier
    on each sample.', uid: Microsoft.Quantum.MachineLearning.EstimateClassificationProbabilities}
- {summary: 'Given a sample and a sequential classifier, estimates the classification
    probability for that sample by repeatedly measuring the output of the classifier
    on the given sample.', uid: Microsoft.Quantum.MachineLearning.EstimateClassificationProbability}
- {summary: Estimates the training gradient for a sequential classifier at a particular
    model and for a given encoded input., uid: Microsoft.Quantum.MachineLearning.EstimateGradient}
- {summary: 'Given the structure of a sequential classifier, trains the classifier
    on a given labeled training set.', uid: Microsoft.Quantum.MachineLearning.TrainSequentialClassifier}
- {summary: 'Given the structure of a sequential classifier, trains the classifier
    on a given labeled training set, starting from a particular model.', uid: Microsoft.Quantum.MachineLearning.TrainSequentialClassifierAtModel}
- {summary: Validates a given sequential classifier against a given set of pre-labeled
    samples., uid: Microsoft.Quantum.MachineLearning.ValidateSequentialClassifier}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._ApplyLEOperationToRawRegister}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._ApplyTwoQubitCase}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._EstimateDerivativeWithParameterShift}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._PrepareClassification}
- {summary: Randomly rescales an input to either grow or shrink by a given factor.,
  uid: Microsoft.Quantum.MachineLearning._RandomlyRescale}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._ReflectAboutNegativeCoefficients}
- {summary: Perform one epoch of sequential classifier training on a subset of data
    samples., uid: Microsoft.Quantum.MachineLearning._RunSingleTrainingEpoch}
- {summary: attempts a single parameter update in the direction of mini batch gradient,
  uid: Microsoft.Quantum.MachineLearning._RunSingleTrainingStep}
- {summary: '', uid: Microsoft.Quantum.MachineLearning._TrainSequentialClassifierAtModel}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nRandomInt has been deprecated. Please\
    \ use @\"microsoft.quantum.random.drawrandomint\" instead.", uid: Microsoft.Quantum.Math.RandomInt}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nRandomIntPow2 has been deprecated. Please\
    \ use @\"microsoft.quantum.random.drawrandomint\" instead.", uid: Microsoft.Quantum.Math.RandomIntPow2}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nRandomReal has been deprecated. Please\
    \ use @\"microsoft.quantum.random.drawrandomdouble\" instead.", uid: Microsoft.Quantum.Math.RandomReal}
- {summary: "\n> [!WARNING]\n> Deprecated\n\nRandomSingleQubitPauli has been deprecated.\
    \ Please use @\"microsoft.quantum.random.drawrandompauli\" instead.", uid: Microsoft.Quantum.Math.RandomSingleQubitPauli}
- {summary: '', uid: Microsoft.Quantum.Measurement.BasisChangeZtoY}
- {summary: 'Measures a single qubit in the X basis, and resets it to a fixed initial
    state following the measurement.', uid: Microsoft.Quantum.Measurement.MResetX}
- {summary: 'Measures a single qubit in the Y basis, and resets it to a fixed initial
    state following the measurement.', uid: Microsoft.Quantum.Measurement.MResetY}
- {summary: 'Measures a single qubit in the Z basis, and resets it to a fixed initial
    state following the measurement.', uid: Microsoft.Quantum.Measurement.MResetZ}
- {summary: Jointly measures a register of qubits in the Pauli Z basis., uid: Microsoft.Quantum.Measurement.MeasureAllZ}
- {summary: 'Given an array of multi-qubit Pauli operators, measures each using a
    specified measurement gadget, then returns the array of results.', uid: Microsoft.Quantum.Measurement.MeasurePaulis}
- {summary: Measures the given Pauli operator using an explicit scratch qubit to perform
    the measurement., uid: Microsoft.Quantum.Measurement.MeasureWithScratch}
- {summary: Measures each qubit in a given array in the standard basis., uid: Microsoft.Quantum.Measurement.MultiM}
- {summary: Sets a qubit to a given computational basis state by measuring the qubit
    and applying a bit flip if needed., uid: Microsoft.Quantum.Measurement.SetToBasisState}
- {summary: Implementation of <xref:microsoft.quantum.canon.deterministicstateoraclefromstateoracle>.,
  uid: Microsoft.Quantum.Oracles.ApplyDeterministicStateOracleFromStateOracle}
- {summary: Implementation of <xref:microsoft.quantum.canon.obliviousoraclefromdeterministicstateoracle>.,
  uid: Microsoft.Quantum.Oracles.ApplyObliviousOracleFromDeterministicStateOracle}
- {summary: Implementation of <xref:microsoft.quantum.canon.stateoraclefromdeterministicstateoracle>.,
  uid: Microsoft.Quantum.Oracles.ApplyStateOracleFromDeterministicStateOracle}
- {summary: Implementation of <xref:microsoft.quantum.canon.reflectionoraclefromdeterministicstateoracle>.,
  uid: Microsoft.Quantum.Oracles._ReflectionOracleFromDeterministicStateOracle}
- {summary: '', uid: Microsoft.Quantum.Preparation.ApplyGlobalRotationStep}
- {summary: '', uid: Microsoft.Quantum.Preparation.ApplyMultiplexStep}
- {summary: 'Applies an operation to the underlying qubits making up a little-endian
    register. This operation is marked as internal, as a little-endian register is
    intended to be "opaque," such that this is an implementation detail only.', uid: Microsoft.Quantum.Preparation.ApplyToLittleEndian}
- {summary: 'Given a set of coefficients and a little-endian encoded quantum register,
    prepares an state on that register described by the given coefficients, up to
    a given approximation tolerance.', uid: Microsoft.Quantum.Preparation.ApproximatelyPrepareArbitraryState}
- {summary: 'Given a set of coefficients and a little-endian encoded quantum register,
    prepares an state on that register described by the given coefficients.', uid: Microsoft.Quantum.Preparation.PrepareArbitraryState}
- {summary: "Prepares the Choi\u2013Jami\u0142kowski state for a given operation onto\
    \ given reference and target registers.", uid: Microsoft.Quantum.Preparation.PrepareChoiState}
- {summary: "Prepares the Choi\u2013Jami\u0142kowski state for a given operation with\
    \ an adjoint variant onto given reference and target registers.", uid: Microsoft.Quantum.Preparation.PrepareChoiStateA}
- {summary: "Prepares the Choi\u2013Jami\u0142kowski state for a given operation with\
    \ a controlled variant onto given reference and target registers.", uid: Microsoft.Quantum.Preparation.PrepareChoiStateC}
- {summary: "Prepares the Choi\u2013Jami\u0142kowski state for a given operation with\
    \ both controlled and adjoint variants onto given reference and target registers.",
  uid: Microsoft.Quantum.Preparation.PrepareChoiStateCA}
- {summary: "Pairwise entangles two qubit registers.\nThat is, given two registers,\
    \ prepares the maximally entangled state $\\frac{1}{\\sqrt{2}} \\left(\\ket{00}\
    \ + \\ket{11} \\right)$ between each pair of qubits on the respective registers,\
    \ assuming that each register starts in the $\\ket{0\\cdots 0}$ state.", uid: Microsoft.Quantum.Preparation.PrepareEntangledState}
- {summary: "Given a register, prepares that register in the maximally mixed state.\n\
    The register is prepared in the $\\boldone / 2^N$ state by applying the complete\
    \ depolarizing channel to each qubit, where $N$ is the length of the register.",
  uid: Microsoft.Quantum.Preparation.PrepareIdentity}
- {summary: '', uid: Microsoft.Quantum.Preparation.PrepareQuantumROMState}
- {summary: "Prepares a qubit in the +1 (`Zero`) eigenstate of the given Pauli operator.\
    \ If the identity operator is given, then the qubit is prepared in the maximally\
    \ mixed state.\nIf the qubit was initially in the $\\ket{0}$ state, this operation\
    \ prepares the qubit in the $+1$ eigenstate of a given Pauli operator, or, for\
    \ `PauliI`, in the maximally mixed state instead (see <xref:microsoft.quantum.preparation.preparesinglequbitidentity>).\n\
    If the qubit was in a state other than $\\ket{0}$, this operation applies the\
    \ following gates: $H$ for `PauliX`, $HS$ for `PauliY`, $I$ for `PauliZ` and <xref:microsoft.quantum.preparation.preparesinglequbitidentity>\
    \ for `PauliI`.", uid: Microsoft.Quantum.Preparation.PrepareQubit}
- {summary: "Prepares a qubit in the maximally mixed state.\nIt prepares the given\
    \ qubit in the $\\boldone / 2$ state by applying the depolarizing channel $$ \\\
    begin{align} \\Omega(\\rho) \\mathrel{:=} \\frac{1}{4} \\sum_{\\mu \\in \\{0,\
    \ 1, 2, 3\\}} \\sigma\\_{\\mu} \\rho \\sigma\\_{\\mu}^{\\dagger}, \\end{align}\
    \ $$ where $\\sigma\\_i$ is the $i$th Pauli operator, and where $\\rho$ is a density\
    \ operator representing a mixed state.", uid: Microsoft.Quantum.Preparation.PrepareSingleQubitIdentity}
- {summary: "Creates a uniform superposition over states that encode 0 through `nIndices\
    \ - 1`.\nThat is, this unitary $U$ creates a uniform superposition over all number\
    \ states $0$ to $M-1$, given an input state $\\ket{0\\cdots 0}$. In other words,\
    \ $$ \\begin{align} U\\ket{0}=\\frac{1}{\\sqrt{M}}\\sum_{j=0}^{M-1}\\ket{j}. \\\
    end{align} $$.", uid: Microsoft.Quantum.Preparation.PrepareUniformSuperposition}
- {summary: Implementation step of <xref:microsoft.quantum.canon.prepareuniformsuperposition>,
  uid: Microsoft.Quantum.Preparation.PrepareUniformSuperposition_}
- {summary: '', uid: Microsoft.Quantum.Preparation.WriteQuantumROMBitString}
- {summary: '', uid: Microsoft.Quantum.Random.Delay}
- {summary: Draws a random sample from a categorical distribution specified by a list
    of probablities., uid: Microsoft.Quantum.Random.DrawCategorical}
- {summary: 'Given a success probability, returns a single Bernoulli trial that is
    true with the given probability.', uid: Microsoft.Quantum.Random.DrawRandomBool}
- {summary: Draws a random real number in a given inclusive interval., uid: Microsoft.Quantum.Random.DrawRandomDouble}
- {summary: Draws a random integer in a given inclusive range., uid: Microsoft.Quantum.Random.DrawRandomInt}
- {summary: Draws a random Pauli value., uid: Microsoft.Quantum.Random.DrawRandomPauli}
- {summary: '', uid: Microsoft.Quantum.Random.DrawStandardNormalVariate}
- {summary: 'Given an array of data and an a distribution over its indices, attempts
    to choose an element at random.', uid: Microsoft.Quantum.Random.MaybeChooseElement}
- {summary: Internal-only operation for sampling from transformed distributions. Should
    only be used via partial application., uid: Microsoft.Quantum.Random.SampleTransformedContinuousDistribution}
- {summary: Performs iterative phase estimation using a random walk to approximate
    Bayesian inference on the classical measurement results from a given oracle and
    eigenstate., uid: Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation}
- {summary: '', uid: Microsoft.Quantum.Research.Characterization._PrepAndMeasurePhaseEst}
- {summary: '', uid: Microsoft.Quantum.Research.Chemistry.ApplyBasisChange}
- {summary: Computes difference in parity between a previous PQRS... terms and the
    next PQRS... term. This difference is computed on a auxiliary qubit., uid: Microsoft.Quantum.Research.Chemistry.ApplyDeltaParity}
- {summary: Simple state preparation of trial state by occupying spin-orbitals, uid: Microsoft.Quantum.Research.Chemistry.JWOptimizedStatePreparation}
- {summary: Used to change the basis of a Z operator to a Y operator. conjugation.,
  uid: Microsoft.Quantum.Research.Chemistry.TransformZToX}
- {summary: Used to change the basis of a Z operator to a Y operator by conjugation.,
  uid: Microsoft.Quantum.Research.Chemistry.TransformZToY}
- {summary: '', uid: Microsoft.Quantum.Research.Chemistry._ApplyOptimizedTrotterStep}
- {summary: Applies time-evolution by a PQRS term described by a `GeneratorIndex`.,
  uid: Microsoft.Quantum.Research.Chemistry._JWOptimized0123Term}
- {summary: Implementation step of `JWOptimized0123Term_`;, uid: Microsoft.Quantum.Research.Chemistry._JWOptimized0123TermImpl}
- {summary: "Represents a dynamical generator as a set of simulatable gates and an\
    \ expansion in the JWOptimized basis.\nSee [Dynamical Generator Modeling](../libraries/data-structures#dynamical-generator-modeling)\
    \ for more details.", uid: Microsoft.Quantum.Research.Chemistry._JWOptimizedFermionEvolution}
- {summary: Applies time-evolution by a PQ term described by a `GeneratorIndex`.,
  uid: Microsoft.Quantum.Research.Chemistry._JWOptimizedHpqTerm}
- {summary: Implementation step of `JWOptimizedHpqTerm_`., uid: Microsoft.Quantum.Research.Chemistry._JWOptimizedHpqTermImpl}
- {summary: Applies time-evolution by a PQ or PQQR term described by a `GeneratorIndex`.,
  uid: Microsoft.Quantum.Research.Chemistry._JWOptimizedPQandPQQRTerm}
- {summary: 'Applies a Rz rotation, with a C-NOT trick to double phase in phase estimation.',
  uid: Microsoft.Quantum.Research.Chemistry._JWOptimizedZ}
- {summary: Applies time-evolution by a Z term described by a `GeneratorIndex`., uid: Microsoft.Quantum.Research.Chemistry._JWOptimizedZTerm}
- {summary: Applies time-evolution by a ZZ term described by a `GeneratorIndex`.,
  uid: Microsoft.Quantum.Research.Chemistry._JWOptimizedZZTerm}
- {summary: 'Performs state preparation by applying a `statePrepUnitary` on the input
    state, followed by adiabatic state preparation using a `adiabaticUnitary`, and
    finally phase estimation with respect to `qpeUnitary`on the resulting state using
    a `phaseEstAlgorithm`.', uid: Microsoft.Quantum.Simulation.AdiabaticStateEnergyUnitary}
- {summary: Implementation of `BlockEncodingToReflection`., uid: Microsoft.Quantum.Simulation.ApplyBlockEncodingAsReflection}
- {summary: Implementation of `BlockEncodingByLCU`., uid: Microsoft.Quantum.Simulation.ApplyBlockEncodingByLCU}
- {summary: 'Conversion of ((LittleEndian, Qubit[]) => () is Adj + Ctl) to BlockEncoding',
  uid: Microsoft.Quantum.Simulation.ApplyBlockEncodingFromBEandQubit}
- {summary: Used in implementation of `PauliBlockEncoding`, uid: Microsoft.Quantum.Simulation.ApplyPauliLCUUnitary}
- {summary: Implementation of `Qubitization`., uid: Microsoft.Quantum.Simulation.ApplyQuantumWalkByQubitization}
- {summary: Performs state preparation by applying a `statePrepUnitary` on an automatically
    allocated input state phase estimation with respect to `qpeUnitary`on the resulting
    state using a `phaseEstAlgorithm`., uid: Microsoft.Quantum.Simulation.EstimateEnergy}
- {summary: 'Performs state preparation by applying a `statePrepUnitary` on an automatically
    allocated input state, followed by adiabatic state preparation using a `adiabaticUnitary`,
    and finally phase estimation with respect to `qpeUnitary`on the resulting state
    using a `phaseEstAlgorithm`.', uid: Microsoft.Quantum.Simulation.EstimateEnergyWithAdiabaticEvolution}
- {summary: "Represents a dynamical generator as a set of simulatable gates and an\
    \ expansion in the Pauli basis.\nSee [Dynamical Generator Modeling](/quantum/libraries/data-structures#dynamical-generator-modeling)\
    \ for more details.", uid: Microsoft.Quantum.Simulation.PauliEvolutionImpl}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyConditionally}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyConditionallyA}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyConditionallyC}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyConditionallyCA}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyConditionallyIntrinsic}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyConditionallyIntrinsicA}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyConditionallyIntrinsicC}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyConditionallyIntrinsicCA}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfElseIntrinsic}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfElseIntrinsicA}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfElseIntrinsicC}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfElseIntrinsicCA}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfElseR}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfElseRA}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfElseRC}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfElseRCA}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfOne}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfOneA}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfOneC}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfOneCA}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfZero}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfZeroA}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfZeroC}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.ApplyIfZeroCA}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.Delay}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.DelayA}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.DelayC}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.DelayCA}
- {summary: '', uid: Microsoft.Quantum.Simulation.QuantumProcessor.Extensions.NoOp}
- {summary: "Implementation of multiple Trotter steps to approximate a unitary operator\
    \ that solves the time-dependent Schr\xF6dinger equation.", uid: Microsoft.Quantum.Simulation.TimeDependentTrotterSimulationAlgorithmImpl}
- {summary: Makes repeated calls to `TrotterStep` to approximate the time-evolution
    operator exp(_-iHt_)., uid: Microsoft.Quantum.Simulation.TrotterSimulationAlgorithmImpl}
- {summary: Implements time-evolution by a term contained in a `GeneratorSystem`.,
  uid: Microsoft.Quantum.Simulation.TrotterStepImpl}
- {summary: Permutes the amplitudes in a quantum state given a permutation using decomposition-based
    synthesis., uid: Microsoft.Quantum.Synthesis.ApplyPermutationUsingDecomposition}
- {summary: Permutes the amplitudes in a quantum state given a permutation using decomposition-based
    synthesis., uid: Microsoft.Quantum.Synthesis.ApplyPermutationUsingDecompositionWithVariableOrder}
- {summary: Permutes the amplitudes in a quantum state given a permutation using transformation-based
    synthesis., uid: Microsoft.Quantum.Synthesis.ApplyPermutationUsingTransformation}
- {summary: '', uid: Microsoft.Quantum.Synthesis.ApplyTransposition}
- {summary: 'Applies the @"microsoft.quantum.intrinsic.x" operation on `target`, if
    the Boolean function `func` evaluates to true for the classical assignment in
    `controlRegister`.', uid: Microsoft.Quantum.Synthesis.ApplyXControlledOnTruthTable}
- {summary: 'Applies the @"microsoft.quantum.intrinsic.x" operation on `target`, if
    the Boolean function `func` evaluates to true for the classical assignment in
    `controlRegister`.', uid: Microsoft.Quantum.Synthesis.ApplyXControlledOnTruthTableWithCleanTarget}
summary: ''
uid: Microsoft.Quantum.Chemistry.JordanWigner.VQE
